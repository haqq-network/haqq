{
  "swagger": "2.0",
  "info": {
    "title": "Haqq Network gRPC API",
    "version": "1.8.0"
  },
  "tags": [
    {
      "name": "Query"
    },
    {
      "name": "ABCIService"
    },
    {
      "name": "Service"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/cosmos/auth/v1beta1/account_info/{address}": {
      "get": {
        "summary": "AccountInfo queries account info which is common to all account types.",
        "operationId": "AccountInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryAccountInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the account address string.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/accounts": {
      "get": {
        "summary": "Accounts returns all the existing accounts.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Accounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryAccountsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/accounts/{address}": {
      "get": {
        "summary": "Account returns account details based on address.",
        "operationId": "Account",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryAccountResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address defines the address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/address_by_id/{id}": {
      "get": {
        "summary": "AccountAddressByID returns account address based on account number.",
        "operationId": "AccountAddressByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Deprecated, use account_id instead\n\nid is the account number of the address to be queried. This field\nshould have been an uint64 (like all account numbers), and will be\nupdated to uint64 in a future version of the auth query.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "account_id is the account number of the address to be queried.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/bech32": {
      "get": {
        "summary": "Bech32Prefix queries bech32Prefix",
        "operationId": "Bech32Prefix",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.Bech32PrefixResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/bech32/{addressBytes}": {
      "get": {
        "summary": "AddressBytesToString converts Account Address bytes to string",
        "operationId": "AddressBytesToString",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.AddressBytesToStringResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "addressBytes",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/bech32/{addressString}": {
      "get": {
        "summary": "AddressStringToBytes converts Address string to bytes",
        "operationId": "AddressStringToBytes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.AddressStringToBytesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "addressString",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/module_accounts": {
      "get": {
        "summary": "ModuleAccounts returns all the existing module accounts.",
        "operationId": "ModuleAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryModuleAccountsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/module_accounts/{name}": {
      "get": {
        "summary": "ModuleAccountByName returns the module account info by module name",
        "operationId": "ModuleAccountByName",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.auth.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants": {
      "get": {
        "summary": "Returns list of `Authorization`, granted to the grantee by the granter.",
        "operationId": "Grants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.QueryGrantsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "grantee",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msgTypeUrl",
            "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants/grantee/{grantee}": {
      "get": {
        "summary": "GranteeGrants returns a list of `GrantAuthorization` by grantee.",
        "operationId": "GranteeGrants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.QueryGranteeGrantsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants/granter/{granter}": {
      "get": {
        "summary": "GranterGrants returns list of `GrantAuthorization`, granted by granter.",
        "operationId": "GranterGrants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.QueryGranterGrantsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}": {
      "get": {
        "summary": "AllBalances queries the balance of all coins for a single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "AllBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryAllBalancesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "resolveDenom",
            "description": "resolve_denom is the flag to resolve the denom into a human-readable form from the metadata.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
      "get": {
        "summary": "Balance queries the balance of a single coin for a single account.",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryBalanceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denom_owners/{denom}": {
      "get": {
        "summary": "DenomOwners queries for all account addresses that own a particular token\ndenomination.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DenomOwners",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryDenomOwnersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom defines the coin denomination to query all account holders for.",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": ".+"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denom_owners_by_query": {
      "get": {
        "summary": "DenomOwnersByQuery queries for all account addresses that own a particular token\ndenomination.",
        "operationId": "DenomOwnersByQuery",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom defines the coin denomination to query all account holders for.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata": {
      "get": {
        "summary": "DenomsMetadata queries the client metadata for all registered coin\ndenominations.",
        "operationId": "DenomsMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryDenomsMetadataResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
      "get": {
        "summary": "DenomMetadata queries the client metadata of a given coin denomination.",
        "operationId": "DenomMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryDenomMetadataResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query the metadata for.",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": ".+"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata_by_query_string": {
      "get": {
        "summary": "DenomMetadataByQueryString queries the client metadata of a given coin denomination.",
        "operationId": "DenomMetadataByQueryString",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query the metadata for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of x/bank module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/send_enabled": {
      "get": {
        "summary": "SendEnabled queries for SendEnabled entries.",
        "description": "This query only returns denominations that have specific SendEnabled settings.\nAny denomination that does not have a specific setting will use the default\nparams.default_send_enabled, and will not be returned by this query.",
        "operationId": "SendEnabled",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QuerySendEnabledResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denoms",
            "description": "denoms is the specific denoms you want look up. Leave empty to get all entries.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}": {
      "get": {
        "summary": "SpendableBalances queries the spendable balance of all coins for a single\naccount.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "SpendableBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QuerySpendableBalancesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query spendable balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom": {
      "get": {
        "summary": "SpendableBalanceByDenom queries the spendable balance of a single denom for\na single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "SpendableBalanceByDenom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply": {
      "get": {
        "summary": "TotalSupply queries the total supply of all coins.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "TotalSupply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QueryTotalSupplyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply/by_denom": {
      "get": {
        "summary": "SupplyOf queries the supply of a single coin.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "SupplyOf",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.bank.v1beta1.QuerySupplyOfResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/base/node/v1beta1/config": {
      "get": {
        "summary": "Config queries for the operator configuration.",
        "operationId": "Config",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.node.v1beta1.ConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/node/v1beta1/status": {
      "get": {
        "summary": "Status queries for the node status.",
        "operationId": "Status",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.node.v1beta1.StatusResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/abci_query": {
      "get": {
        "summary": "ABCIQuery defines a query handler that supports ABCI queries directly to the\napplication, bypassing Tendermint completely. The ABCI query must contain\na valid and supported path, including app, custom, p2p, and store.",
        "operationId": "ABCIQuery",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.ABCIQueryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "data",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "path",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "height",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "prove",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/latest": {
      "get": {
        "summary": "GetLatestBlock returns the latest block.",
        "operationId": "GetLatestBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.GetLatestBlockResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
      "get": {
        "summary": "GetBlockByHeight queries block for given height.",
        "operationId": "GetBlockByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/node_info": {
      "get": {
        "summary": "GetNodeInfo queries the current node info.",
        "operationId": "GetNodeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.GetNodeInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/syncing": {
      "get": {
        "summary": "GetSyncing queries node syncing.",
        "operationId": "GetSyncing",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.GetSyncingResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
      "get": {
        "summary": "GetLatestValidatorSet queries latest validator-set.",
        "operationId": "GetLatestValidatorSet",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
      "get": {
        "summary": "GetValidatorSetByHeight queries validator-set at a given height.",
        "operationId": "GetValidatorSetByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/circuit/v1/accounts": {
      "get": {
        "summary": "Account returns account permissions.",
        "operationId": "Accounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.circuit.v1.AccountsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/circuit/v1/accounts/{address}": {
      "get": {
        "summary": "Account returns account permissions.",
        "operationId": "Account",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.circuit.v1.AccountResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/circuit/v1/disable_list": {
      "get": {
        "summary": "DisabledList returns a list of disabled message urls",
        "operationId": "DisabledList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.circuit.v1.DisabledListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/consensus/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/consensus module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.consensus.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/community_pool": {
      "get": {
        "summary": "CommunityPool queries the community pool coins.",
        "description": "WARNING: This query will fail if an external community pool is used.",
        "operationId": "CommunityPool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryCommunityPoolResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/rewards": {
      "get": {
        "summary": "DelegationTotalRewards queries the total rewards accrued by each\nvalidator.",
        "operationId": "DelegationTotalRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddress",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/rewards/{validatorAddress}": {
      "get": {
        "summary": "DelegationRewards queries the total rewards accrued by a delegation.",
        "operationId": "DelegationRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddress",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "validatorAddress",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/validators": {
      "get": {
        "summary": "DelegatorValidators queries the validators of a delegator.",
        "operationId": "DelegatorValidators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddress",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/withdraw_address": {
      "get": {
        "summary": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
        "operationId": "DelegatorWithdrawAddress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddress",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/params": {
      "get": {
        "summary": "Params queries params of the distribution module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}": {
      "get": {
        "summary": "ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator",
        "operationId": "ValidatorDistributionInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddress",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}/commission": {
      "get": {
        "summary": "ValidatorCommission queries accumulated commission for a validator.",
        "operationId": "ValidatorCommission",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddress",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}/outstanding_rewards": {
      "get": {
        "summary": "ValidatorOutstandingRewards queries rewards of a validator address.",
        "operationId": "ValidatorOutstandingRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddress",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validatorAddress}/slashes": {
      "get": {
        "summary": "ValidatorSlashes queries slash events of a validator.",
        "operationId": "ValidatorSlashes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddress",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "startingHeight",
            "description": "starting_height defines the optional starting height to query the slashes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "endingHeight",
            "description": "starting_height defines the optional ending height to query the slashes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/epochs/v1beta1/current_epoch": {
      "get": {
        "summary": "CurrentEpoch provide current epoch of specified identifier",
        "operationId": "CurrentEpoch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.epochs.v1beta1.QueryCurrentEpochResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "identifier",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/epochs/v1beta1/epochs": {
      "get": {
        "summary": "EpochInfos provide running epochInfos",
        "operationId": "EpochInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.epochs.v1beta1.QueryEpochInfosResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence": {
      "get": {
        "summary": "AllEvidence queries all evidence.",
        "operationId": "AllEvidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.evidence.v1beta1.QueryAllEvidenceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence/{hash}": {
      "get": {
        "summary": "Evidence queries evidence based on evidence hash.",
        "operationId": "Evidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.evidence.v1beta1.QueryEvidenceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash defines the evidence hash of the requested evidence.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "evidenceHash",
            "description": "evidence_hash defines the hash of the requested evidence.\nDeprecated: Use hash, a HEX encoded string, instead.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
      "get": {
        "summary": "Allowance returns granted allwance to the grantee by the granter.",
        "operationId": "Allowance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.feegrant.v1beta1.QueryAllowanceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "description": "granter is the address of the user granting an allowance of their funds.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "grantee",
            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
      "get": {
        "summary": "Allowances returns all the grants for the given grantee address.",
        "operationId": "Allowances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.feegrant.v1beta1.QueryAllowancesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/issued/{granter}": {
      "get": {
        "summary": "AllowancesByGranter returns all the grants given by an address",
        "operationId": "AllowancesByGranter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/constitution": {
      "get": {
        "summary": "Constitution queries the chain's constitution.",
        "operationId": "Constitution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryConstitutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/params/{paramsType}": {
      "get": {
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "paramsType",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals": {
      "get": {
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "Proposals",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryProposalsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalStatus",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ],
            "default": "PROPOSAL_STATUS_UNSPECIFIED"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}": {
      "get": {
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryProposalResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/deposits": {
      "get": {
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "Deposits",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryDepositsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/deposits/{depositor}": {
      "get": {
        "summary": "Deposit queries single deposit information based on proposalID, depositAddr.",
        "operationId": "Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryDepositResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/tally": {
      "get": {
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryTallyResultResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/votes": {
      "get": {
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "Votes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryVotesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposalId}/votes/{voter}": {
      "get": {
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "Vote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1.QueryVoteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/params/{paramsType}": {
      "get": {
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "paramsType",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals": {
      "get": {
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "Proposals",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryProposalsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalStatus",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ],
            "default": "PROPOSAL_STATUS_UNSPECIFIED"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}": {
      "get": {
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryProposalResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/deposits": {
      "get": {
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "Deposits",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryDepositsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/deposits/{depositor}": {
      "get": {
        "summary": "Deposit queries single deposit information based on proposalID, depositor address.",
        "operationId": "Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryDepositResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/tally": {
      "get": {
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryTallyResultResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/votes": {
      "get": {
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "Votes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryVotesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposalId}/votes/{voter}": {
      "get": {
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "Vote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.gov.v1beta1.QueryVoteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/group_info/{groupId}": {
      "get": {
        "summary": "GroupInfo queries group info based on group id.",
        "operationId": "GroupInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "groupId",
            "description": "group_id is the unique ID of the group.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/group_members/{groupId}": {
      "get": {
        "summary": "GroupMembers queries members of a group by group id.",
        "operationId": "GroupMembers",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupMembersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "groupId",
            "description": "group_id is the unique ID of the group.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/group_policies_by_admin/{admin}": {
      "get": {
        "summary": "GroupPoliciesByAdmin queries group policies by admin address.",
        "operationId": "GroupPoliciesByAdmin",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupPoliciesByAdminResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "admin",
            "description": "admin is the admin address of the group policy.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/group_policies_by_group/{groupId}": {
      "get": {
        "summary": "GroupPoliciesByGroup queries group policies by group id.",
        "operationId": "GroupPoliciesByGroup",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupPoliciesByGroupResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "groupId",
            "description": "group_id is the unique ID of the group policy's group.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/group_policy_info/{address}": {
      "get": {
        "summary": "GroupPolicyInfo queries group policy info based on account address of group policy.",
        "operationId": "GroupPolicyInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupPolicyInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the account address of the group policy.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/groups": {
      "get": {
        "summary": "Groups queries all groups in state.",
        "operationId": "Groups",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/groups_by_admin/{admin}": {
      "get": {
        "summary": "GroupsByAdmin queries groups by admin address.",
        "operationId": "GroupsByAdmin",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupsByAdminResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "admin",
            "description": "admin is the account address of a group's admin.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/groups_by_member/{address}": {
      "get": {
        "summary": "GroupsByMember queries groups by member address.",
        "operationId": "GroupsByMember",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryGroupsByMemberResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the group member address.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/proposal/{proposalId}": {
      "get": {
        "summary": "Proposal queries a proposal based on proposal id.",
        "operationId": "Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryProposalResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id is the unique ID of a proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/proposals/{proposalId}/tally": {
      "get": {
        "summary": "TallyResult returns the tally result of a proposal. If the proposal is\nstill in voting period, then this query computes the current tally state,\nwhich might not be final. On the other hand, if the proposal is final,\nthen it simply returns the `final_tally_result` state stored in the\nproposal itself.",
        "operationId": "TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryTallyResultResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id is the unique id of a proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/proposals_by_group_policy/{address}": {
      "get": {
        "summary": "ProposalsByGroupPolicy queries proposals based on account address of group policy.",
        "operationId": "ProposalsByGroupPolicy",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryProposalsByGroupPolicyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the account address of the group policy related to proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/vote_by_proposal_voter/{proposalId}/{voter}": {
      "get": {
        "summary": "VoteByProposalVoter queries a vote by proposal id and voter.",
        "operationId": "VoteByProposalVoter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryVoteByProposalVoterResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id is the unique ID of a proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter is a proposal voter account address.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/votes_by_proposal/{proposalId}": {
      "get": {
        "summary": "VotesByProposal queries a vote by proposal id.",
        "operationId": "VotesByProposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryVotesByProposalResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "proposalId",
            "description": "proposal_id is the unique ID of a proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/group/v1/votes_by_voter/{voter}": {
      "get": {
        "summary": "VotesByVoter queries a vote by voter.",
        "operationId": "VotesByVoter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.group.v1.QueryVotesByVoterResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "voter",
            "description": "voter is a proposal voter account address.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/annual_provisions": {
      "get": {
        "summary": "AnnualProvisions current minting annual provisions value.",
        "operationId": "AnnualProvisions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/inflation": {
      "get": {
        "summary": "Inflation returns the current minting inflation value.",
        "operationId": "Inflation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.mint.v1beta1.QueryInflationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/params": {
      "get": {
        "summary": "Params returns the total set of minting parameters.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.mint.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/balance/{owner}/{classId}": {
      "get": {
        "summary": "Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QueryBalanceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "owner",
            "description": "owner is the owner address of the nft",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "classId",
            "description": "class_id associated with the nft",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/classes": {
      "get": {
        "summary": "Classes queries all NFT classes",
        "operationId": "Classes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QueryClassesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/classes/{classId}": {
      "get": {
        "summary": "Class queries an NFT class based on its id",
        "operationId": "Class",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QueryClassResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "classId",
            "description": "class_id associated with the nft",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/nfts": {
      "get": {
        "summary": "NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in\nERC721Enumerable",
        "operationId": "NFTs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QueryNFTsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "classId",
            "description": "class_id associated with the nft",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "owner",
            "description": "owner is the owner address of the nft",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/nfts/{classId}/{id}": {
      "get": {
        "summary": "NFT queries an NFT based on its class and id.",
        "operationId": "NFT",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QueryNFTResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "classId",
            "description": "class_id associated with the nft",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "description": "id is a unique identifier of the NFT",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/owner/{classId}/{id}": {
      "get": {
        "summary": "Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721",
        "operationId": "Owner",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QueryOwnerResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "classId",
            "description": "class_id associated with the nft",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "description": "id is a unique identifier of the NFT",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/nft/v1beta1/supply/{classId}": {
      "get": {
        "summary": "Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.",
        "operationId": "Supply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.nft.v1beta1.QuerySupplyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "classId",
            "description": "class_id associated with the nft",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/params/v1beta1/params": {
      "get": {
        "summary": "Params queries a specific parameter of a module, given its subspace and\nkey.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.params.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "subspace",
            "description": "subspace defines the module to query the parameter for.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "key",
            "description": "key defines the key of the parameter in the subspace.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/params/v1beta1/subspaces": {
      "get": {
        "summary": "Subspaces queries for all registered subspaces and all keys for a subspace.",
        "operationId": "Subspaces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.params.v1beta1.QuerySubspacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/protocolpool/v1/community_pool": {
      "get": {
        "summary": "CommunityPool queries the community pool coins.",
        "operationId": "CommunityPool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.protocolpool.v1.QueryCommunityPoolResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/protocolpool/v1/continuous_funds": {
      "get": {
        "summary": "ContinuousFunds queries all continuous funds in the store.",
        "operationId": "ContinuousFunds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.protocolpool.v1.QueryContinuousFundsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/protocolpool/v1/continuous_funds/{recipient}": {
      "get": {
        "summary": "ContinuousFund queries a continuous fund by the recipient is is associated with.",
        "operationId": "ContinuousFund",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.protocolpool.v1.QueryContinuousFundResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "recipient",
            "description": "recipient is the recipient address to query unclaimed budget amount for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/protocolpool/v1/params": {
      "get": {
        "summary": "Params returns the total set of x/protocolpool parameters.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.protocolpool.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of slashing module",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.slashing.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos": {
      "get": {
        "summary": "SigningInfos queries signing info of all validators",
        "operationId": "SigningInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.slashing.v1beta1.QuerySigningInfosResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos/{consAddress}": {
      "get": {
        "summary": "SigningInfo queries the signing info of given cons address",
        "operationId": "SigningInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.slashing.v1beta1.QuerySigningInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "consAddress",
            "description": "cons_address is the address to query signing info of",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegations/{delegatorAddr}": {
      "get": {
        "summary": "DelegatorDelegations queries all delegations of a given delegator address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DelegatorDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/redelegations": {
      "get": {
        "summary": "Redelegations queries redelegations of given address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Redelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryRedelegationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "srcValidatorAddr",
            "description": "src_validator_addr defines the validator address to redelegate from.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "dstValidatorAddr",
            "description": "dst_validator_addr defines the validator address to redelegate to.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/unbonding_delegations": {
      "get": {
        "summary": "DelegatorUnbondingDelegations queries all unbonding delegations of a given\ndelegator address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DelegatorUnbondingDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators": {
      "get": {
        "summary": "DelegatorValidators queries all validators info for given delegator\naddress.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DelegatorValidators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators/{validatorAddr}": {
      "get": {
        "summary": "DelegatorValidator queries validator info for given delegator validator\npair.",
        "operationId": "DelegatorValidator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "validatorAddr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/historical_info/{height}": {
      "get": {
        "summary": "HistoricalInfo queries the historical info for given height.",
        "operationId": "HistoricalInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryHistoricalInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "description": "height defines at which height to query the historical info.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/params": {
      "get": {
        "summary": "Parameters queries the staking parameters.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/pool": {
      "get": {
        "summary": "Pool queries the pool info.",
        "operationId": "Pool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryPoolResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators": {
      "get": {
        "summary": "Validators queries all validators that match the given status.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Validators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryValidatorsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "status",
            "description": "status enables to query for validators matching a given status.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}": {
      "get": {
        "summary": "Validator queries validator info for given validator address.",
        "operationId": "Validator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryValidatorResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations": {
      "get": {
        "summary": "ValidatorDelegations queries delegate info for given validator.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "ValidatorDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}": {
      "get": {
        "summary": "Delegation queries delegate info for given validator delegator pair.",
        "operationId": "Delegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryDelegationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}/unbonding_delegation": {
      "get": {
        "summary": "UnbondingDelegation queries unbonding info for given validator delegator\npair.",
        "operationId": "UnbondingDelegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "delegatorAddr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validatorAddr}/unbonding_delegations": {
      "get": {
        "summary": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "ValidatorUnbondingDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "validatorAddr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/tx/v1beta1/decode": {
      "post": {
        "summary": "TxDecode decodes the transaction.",
        "operationId": "TxDecode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxDecodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "TxDecodeRequest is the request type for the Service.TxDecode\nRPC method.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxDecodeRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/decode/amino": {
      "post": {
        "summary": "TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.",
        "operationId": "TxDecodeAmino",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxDecodeAminoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino\nRPC method.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxDecodeAminoRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/encode": {
      "post": {
        "summary": "TxEncode encodes the transaction.",
        "operationId": "TxEncode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxEncodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "TxEncodeRequest is the request type for the Service.TxEncode\nRPC method.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxEncodeRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/encode/amino": {
      "post": {
        "summary": "TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.",
        "operationId": "TxEncodeAmino",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxEncodeAminoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino\nRPC method.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxEncodeAminoRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/simulate": {
      "post": {
        "summary": "Simulate simulates executing a transaction for estimating gas usage.",
        "operationId": "Simulate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.SimulateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "SimulateRequest is the request type for the Service.Simulate\nRPC method.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.SimulateRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs": {
      "get": {
        "summary": "GetTxsEvent fetches txs by event.",
        "operationId": "GetTxsEvent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxsEventResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "events",
            "description": "events is the list of transaction event type.\nDeprecated post v0.47.x: use query instead, which should contain a valid\nevents query.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "orderBy",
            "description": " - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults\nto ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "ORDER_BY_UNSPECIFIED",
              "ORDER_BY_ASC",
              "ORDER_BY_DESC"
            ],
            "default": "ORDER_BY_UNSPECIFIED"
          },
          {
            "name": "page",
            "description": "page is the page number to query, starts at 1. If not provided, will\ndefault to first page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "query",
            "description": "query defines the transaction event query that is proxied to Tendermint's\nTxSearch RPC method. The query must be valid.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Service"
        ]
      },
      "post": {
        "summary": "BroadcastTx broadcast transaction.",
        "operationId": "BroadcastTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.BroadcastTxResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.BroadcastTxRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs/block/{height}": {
      "get": {
        "summary": "GetBlockWithTxs fetches a block with decoded txs.",
        "operationId": "GetBlockWithTxs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetBlockWithTxsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "description": "height is the height of the block to query.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs/{hash}": {
      "get": {
        "summary": "GetTx fetches a tx by hash.",
        "operationId": "GetTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the tx hash to query, encoded as a hex string.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
      "get": {
        "summary": "AppliedPlan queries a previously applied upgrade plan by its name.",
        "operationId": "AppliedPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.QueryAppliedPlanResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "name is the name of the applied plan to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/authority": {
      "get": {
        "summary": "Returns the account with authority to conduct upgrades",
        "operationId": "Authority",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.QueryAuthorityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/current_plan": {
      "get": {
        "summary": "CurrentPlan queries the current upgrade plan.",
        "operationId": "CurrentPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.QueryCurrentPlanResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/module_versions": {
      "get": {
        "summary": "ModuleVersions queries the list of module versions from state.",
        "operationId": "ModuleVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.QueryModuleVersionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "moduleName",
            "description": "module_name is a field to query a specific module\nconsensus version from state. Leaving this empty will\nfetch the full list of module versions from state",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{lastHeight}": {
      "get": {
        "summary": "UpgradedConsensusState queries the consensus state that will serve\nas a trusted kernel for the next version of this chain. It will only be\nstored at the last height of this chain.\nUpgradedConsensusState RPC not supported with legacy querier\nThis rpc is deprecated now that IBC has its own replacement\n(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)",
        "operationId": "UpgradedConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "lastHeight",
            "description": "last height of the current chain must be sent in request\nas this is the height under which next consensus state is stored",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/epochs/v1/current_epoch": {
      "get": {
        "summary": "CurrentEpoch provide current epoch of specified identifier",
        "operationId": "CurrentEpoch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/evmos.epochs.v1.QueryCurrentEpochResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "identifier",
            "description": "identifier of the current epoch",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/epochs/v1/epochs": {
      "get": {
        "summary": "EpochInfos provide running epochInfos",
        "operationId": "EpochInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/evmos.epochs.v1.QueryEpochsInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/erc20/v1/params": {
      "get": {
        "summary": "Params retrieves the erc20 module params",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/evmos.erc20.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/erc20/v1/token_pairs": {
      "get": {
        "summary": "TokenPairs retrieves registered token pairs",
        "operationId": "TokenPairs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/evmos.erc20.v1.QueryTokenPairsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/erc20/v1/token_pairs/{token}": {
      "get": {
        "summary": "TokenPair retrieves a registered token pair",
        "operationId": "TokenPair",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/evmos.erc20.v1.QueryTokenPairResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "token",
            "description": "token identifier can be either the hex contract address of the ERC20 or the\nCosmos base denomination",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/account/{address}": {
      "get": {
        "summary": "Account queries an Ethereum account.",
        "operationId": "Account",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryAccountResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the account for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/balances/{address}": {
      "get": {
        "summary": "Balance queries the balance of a the EVM denomination for a single\nEthAccount.",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryBalanceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the balance for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/base_fee": {
      "get": {
        "summary": "BaseFee queries the base fee of the parent block of the current block,\nit's similar to feemarket module's method, but also checks london hardfork\nstatus.",
        "operationId": "BaseFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryBaseFeeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/codes/{address}": {
      "get": {
        "summary": "Code queries the balance of all coins for a single account.",
        "operationId": "Code",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryCodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the code for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/cosmos_account/{address}": {
      "get": {
        "summary": "CosmosAccount queries an Ethereum account's Cosmos Address.",
        "operationId": "CosmosAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryCosmosAccountResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the account for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/estimate_gas": {
      "get": {
        "summary": "EstimateGas implements the `eth_estimateGas` rpc api",
        "operationId": "EstimateGas",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.EstimateGasResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "args",
            "description": "args uses the same json format as the json rpc api.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "gasCap",
            "description": "gas_cap defines the default gas cap to be used",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "proposerAddress",
            "description": "proposer_address of the requested block in hex format",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chainId",
            "description": "chain_id is the eip155 chain id parsed from the requested block header",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/eth_call": {
      "get": {
        "summary": "EthCall implements the `eth_call` rpc api",
        "operationId": "EthCall",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.MsgEthereumTxResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "args",
            "description": "args uses the same json format as the json rpc api.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "gasCap",
            "description": "gas_cap defines the default gas cap to be used",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "proposerAddress",
            "description": "proposer_address of the requested block in hex format",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chainId",
            "description": "chain_id is the eip155 chain id parsed from the requested block header",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/evm module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/storage/{address}/{key}": {
      "get": {
        "summary": "Storage queries the balance of all coins for a single account.",
        "operationId": "Storage",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryStorageResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the storage state for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "key",
            "description": "key defines the key of the storage state",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/trace_block": {
      "get": {
        "summary": "TraceBlock implements the `debug_traceBlockByNumber` and\n`debug_traceBlockByHash` rpc api",
        "operationId": "TraceBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryTraceBlockResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "traceConfig.tracer",
            "description": "tracer is a custom javascript tracer",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.timeout",
            "description": "timeout overrides the default timeout of 5 seconds for JavaScript-based\ntracing calls",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.reexec",
            "description": "reexec defines the number of blocks the tracer is willing to go back",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "traceConfig.disableStack",
            "description": "disable_stack switches stack capture",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.disableStorage",
            "description": "disable_storage switches storage capture",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.debug",
            "description": "debug can be used to print output during capture end",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.limit",
            "description": "limit defines the maximum length of output, but zero means unlimited",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "traceConfig.overrides.homesteadBlock",
            "description": "homestead_block switch (nil no fork, 0 = already homestead)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.daoForkBlock",
            "description": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.daoForkSupport",
            "description": "dao_fork_support defines whether the nodes supports or opposes the DAO\nhard-fork",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.overrides.eip150Block",
            "description": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.eip150Hash",
            "description": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas\npricing changed)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.eip155Block",
            "description": "eip155_block: EIP155Block HF block",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.eip158Block",
            "description": "eip158_block: EIP158 HF block",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.byzantiumBlock",
            "description": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on\nbyzantium)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.constantinopleBlock",
            "description": "constantinople_block: Constantinople switch block (nil no fork, 0 = already\nactivated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.petersburgBlock",
            "description": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.istanbulBlock",
            "description": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on\nistanbul)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.muirGlacierBlock",
            "description": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =\nalready activated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.berlinBlock",
            "description": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.londonBlock",
            "description": "london_block: London switch block (nil = no fork, 0 = already on london)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.arrowGlacierBlock",
            "description": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =\nalready activated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.grayGlacierBlock",
            "description": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =\nalready activated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.mergeNetsplitBlock",
            "description": "merge_netsplit_block: Virtual fork after The Merge to use as a network\nsplitter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.shanghaiBlock",
            "description": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.cancunBlock",
            "description": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.enableMemory",
            "description": "enable_memory switches memory capture",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.enableReturnData",
            "description": "enable_return_data switches the capture of return data",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.tracerJsonConfig",
            "description": "tracer_json_config configures the tracer using a JSON string",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "blockNumber",
            "description": "block_number of the traced block",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "blockHash",
            "description": "block_hash (hex) of the traced block",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "blockTime",
            "description": "block_time of the traced block",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "proposerAddress",
            "description": "proposer_address is the address of the requested block",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chainId",
            "description": "chain_id is the eip155 chain id parsed from the requested block header",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "blockMaxGas",
            "description": "block_max_gas of the traced block",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/trace_tx": {
      "get": {
        "summary": "TraceTx implements the `debug_traceTransaction` rpc api",
        "operationId": "TraceTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryTraceTxResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "msg.data.typeUrl",
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msg.data.value",
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "msg.size",
            "description": "size is the encoded storage size of the transaction (DEPRECATED)",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "msg.hash",
            "description": "hash of the transaction in hex format",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msg.from",
            "description": "from is the ethereum signer address in hex format. This address value is\nchecked against the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.tracer",
            "description": "tracer is a custom javascript tracer",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.timeout",
            "description": "timeout overrides the default timeout of 5 seconds for JavaScript-based\ntracing calls",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.reexec",
            "description": "reexec defines the number of blocks the tracer is willing to go back",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "traceConfig.disableStack",
            "description": "disable_stack switches stack capture",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.disableStorage",
            "description": "disable_storage switches storage capture",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.debug",
            "description": "debug can be used to print output during capture end",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.limit",
            "description": "limit defines the maximum length of output, but zero means unlimited",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "traceConfig.overrides.homesteadBlock",
            "description": "homestead_block switch (nil no fork, 0 = already homestead)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.daoForkBlock",
            "description": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.daoForkSupport",
            "description": "dao_fork_support defines whether the nodes supports or opposes the DAO\nhard-fork",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.overrides.eip150Block",
            "description": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.eip150Hash",
            "description": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas\npricing changed)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.eip155Block",
            "description": "eip155_block: EIP155Block HF block",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.eip158Block",
            "description": "eip158_block: EIP158 HF block",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.byzantiumBlock",
            "description": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on\nbyzantium)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.constantinopleBlock",
            "description": "constantinople_block: Constantinople switch block (nil no fork, 0 = already\nactivated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.petersburgBlock",
            "description": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.istanbulBlock",
            "description": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on\nistanbul)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.muirGlacierBlock",
            "description": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =\nalready activated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.berlinBlock",
            "description": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.londonBlock",
            "description": "london_block: London switch block (nil = no fork, 0 = already on london)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.arrowGlacierBlock",
            "description": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =\nalready activated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.grayGlacierBlock",
            "description": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =\nalready activated)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.mergeNetsplitBlock",
            "description": "merge_netsplit_block: Virtual fork after The Merge to use as a network\nsplitter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.shanghaiBlock",
            "description": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.overrides.cancunBlock",
            "description": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "traceConfig.enableMemory",
            "description": "enable_memory switches memory capture",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.enableReturnData",
            "description": "enable_return_data switches the capture of return data",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "traceConfig.tracerJsonConfig",
            "description": "tracer_json_config configures the tracer using a JSON string",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "blockNumber",
            "description": "block_number of requested transaction",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "blockHash",
            "description": "block_hash of requested transaction",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "blockTime",
            "description": "block_time of requested transaction",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "proposerAddress",
            "description": "proposer_address is the proposer of the requested block",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chainId",
            "description": "chain_id is the eip155 chain id parsed from the requested block header",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "blockMaxGas",
            "description": "block_max_gas of the block of the requested transaction",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/validator_account/{consAddress}": {
      "get": {
        "summary": "ValidatorAccount queries an Ethereum account's from a validator consensus\nAddress.",
        "operationId": "ValidatorAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.evm.v1.QueryValidatorAccountResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "consAddress",
            "description": "cons_address is the validator cons address to query the account for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/feemarket/v1/base_fee": {
      "get": {
        "summary": "BaseFee queries the base fee of the parent block of the current block.",
        "operationId": "BaseFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.feemarket.v1.QueryBaseFeeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/feemarket/v1/block_gas": {
      "get": {
        "summary": "BlockGas queries the gas used at a given block height",
        "operationId": "BlockGas",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.feemarket.v1.QueryBlockGasResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/feemarket/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/feemarket module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ethermint.feemarket.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/coinomics/v1/params": {
      "get": {
        "summary": "Params retrieves coinomics moudle params.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.coinomics.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/coinomics/v1/reward_coefficient": {
      "get": {
        "summary": "InflationRewardCoefficientRate APY rate for staking rewards",
        "operationId": "RewardCoefficient",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.coinomics.v1.QueryRewardCoefficientResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/liquidvesting/v1/denom": {
      "get": {
        "summary": "Denom queries liquid vesting token info by denom",
        "operationId": "Denom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.liquidvesting.v1.QueryDenomResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is liquidated vesting token",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/liquidvesting/v1/denoms": {
      "get": {
        "summary": "Denoms queries liquid vesting tokens info",
        "operationId": "Denoms",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.liquidvesting.v1.QueryDenomsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/ucdao/v1/balances/{address}": {
      "get": {
        "summary": "AllBalances queries the balance of all coins for a single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "AllBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.ucdao.v1.QueryAllBalancesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/ucdao/v1/balances/{address}/by_denom": {
      "get": {
        "summary": "Balance queries the balance of a single coin for a single account.",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.ucdao.v1.QueryBalanceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/ucdao/v1/holders": {
      "get": {
        "summary": "TokenHolders queries the all balances of all coins locked in the module and\ngroup them by account address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Holders",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.ucdao.v1.QueryHoldersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/ucdao/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/ucdao module.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.ucdao.v1.QueryParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/ucdao/v1/total_balance": {
      "get": {
        "summary": "TotalBalance queries the total balance of all coins locked in the module.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "TotalBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.ucdao.v1.QueryTotalBalanceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.countTotal",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/vesting/v1/balances/{address}": {
      "get": {
        "summary": "Balances retrieves the unvested, vested and locked tokens for a vesting\naccount",
        "operationId": "Balances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.vesting.v1.QueryBalancesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address of the clawback vesting account",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/haqq/vesting/v1/total_locked": {
      "get": {
        "summary": "TotalLocked retrieves the total summary of all unvested, vested and locked\ntokens",
        "operationId": "TotalLocked",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.vesting.v1.QueryTotalLockedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/haqqd/coinomics/v1/max_supply": {
      "get": {
        "summary": "MaxSupply retrieves total coins of all eras and when mint ended.",
        "operationId": "MaxSupply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/haqq.coinomics.v1.QueryMaxSupplyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/google.rpc.Status"
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    }
  },
  "definitions": {
    "cometbft.abci.v2.ApplySnapshotChunkResponse": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/cometbft.abci.v2.ApplySnapshotChunkResult"
        },
        "refetchChunks": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "title": "Chunks to refetch and reapply"
        },
        "rejectSenders": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Chunk senders to reject and ban"
        }
      },
      "description": "ApplySnapshotChunkResponse returns a result of applying the specified chunk."
    },
    "cometbft.abci.v2.ApplySnapshotChunkResult": {
      "type": "string",
      "enum": [
        "APPLY_SNAPSHOT_CHUNK_RESULT_UNKNOWN",
        "APPLY_SNAPSHOT_CHUNK_RESULT_ACCEPT",
        "APPLY_SNAPSHOT_CHUNK_RESULT_ABORT",
        "APPLY_SNAPSHOT_CHUNK_RESULT_RETRY",
        "APPLY_SNAPSHOT_CHUNK_RESULT_RETRY_SNAPSHOT",
        "APPLY_SNAPSHOT_CHUNK_RESULT_REJECT_SNAPSHOT"
      ],
      "default": "APPLY_SNAPSHOT_CHUNK_RESULT_UNKNOWN",
      "description": "The result of applying a snapshot chunk.\n\n - APPLY_SNAPSHOT_CHUNK_RESULT_UNKNOWN: Unknown result, abort all snapshot restoration\n - APPLY_SNAPSHOT_CHUNK_RESULT_ACCEPT: Chunk successfully accepted\n - APPLY_SNAPSHOT_CHUNK_RESULT_ABORT: Abort all snapshot restoration\n - APPLY_SNAPSHOT_CHUNK_RESULT_RETRY: Retry chunk (combine with refetch and reject)\n - APPLY_SNAPSHOT_CHUNK_RESULT_RETRY_SNAPSHOT: Retry snapshot (combine with refetch and reject)\n - APPLY_SNAPSHOT_CHUNK_RESULT_REJECT_SNAPSHOT: Reject this snapshot, try others"
    },
    "cometbft.abci.v2.CheckTxResponse": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "data": {
          "type": "string",
          "format": "byte"
        },
        "log": {
          "type": "string",
          "title": "nondeterministic"
        },
        "info": {
          "type": "string",
          "title": "nondeterministic"
        },
        "gas_wanted": {
          "type": "string",
          "format": "int64"
        },
        "gas_used": {
          "type": "string",
          "format": "int64"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.Event"
          },
          "title": "nondeterministic"
        },
        "codespace": {
          "type": "string"
        },
        "laneId": {
          "type": "string"
        }
      },
      "description": "CheckTxResponse shows if the transaction was deemed valid by the ABCI\napplication."
    },
    "cometbft.abci.v2.CheckTxType": {
      "type": "string",
      "enum": [
        "CHECK_TX_TYPE_UNKNOWN",
        "CHECK_TX_TYPE_RECHECK",
        "CHECK_TX_TYPE_CHECK"
      ],
      "default": "CHECK_TX_TYPE_UNKNOWN",
      "description": "Type of the transaction check request.\n\nThis enumeration is incompatible with the CheckTxType definition in\ncometbft.abci.v1beta1 and therefore shall not be used in encoding with the same\nfield number.\n\n - CHECK_TX_TYPE_UNKNOWN: Unknown\n - CHECK_TX_TYPE_RECHECK: Recheck (2nd, 3rd, etc.)\n - CHECK_TX_TYPE_CHECK: Check (1st time)"
    },
    "cometbft.abci.v2.CommitInfo": {
      "type": "object",
      "properties": {
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.VoteInfo"
          }
        }
      },
      "description": "CommitInfo contains votes for the particular round."
    },
    "cometbft.abci.v2.CommitResponse": {
      "type": "object",
      "properties": {
        "retainHeight": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "CommitResponse indicates how much blocks should CometBFT retain."
    },
    "cometbft.abci.v2.EchoResponse": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        }
      },
      "description": "EchoResponse indicates that the connection is still alive."
    },
    "cometbft.abci.v2.Event": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.EventAttribute"
          }
        }
      },
      "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nUp to 0.37, this could also be used in ResponseBeginBlock, ResponseEndBlock,\nand ResponseDeliverTx.\nLater, transactions may be queried using these events."
    },
    "cometbft.abci.v2.EventAttribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "index": {
          "type": "boolean",
          "title": "nondeterministic"
        }
      },
      "description": "EventAttribute is a single key-value pair, associated with an event."
    },
    "cometbft.abci.v2.ExecTxResult": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "data": {
          "type": "string",
          "format": "byte"
        },
        "log": {
          "type": "string",
          "title": "nondeterministic"
        },
        "info": {
          "type": "string",
          "title": "nondeterministic"
        },
        "gas_wanted": {
          "type": "string",
          "format": "int64"
        },
        "gas_used": {
          "type": "string",
          "format": "int64"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.Event"
          },
          "title": "nondeterministic"
        },
        "codespace": {
          "type": "string"
        }
      },
      "description": "ExecTxResult contains results of executing one individual transaction.\n\n* Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted"
    },
    "cometbft.abci.v2.ExtendVoteResponse": {
      "type": "object",
      "properties": {
        "voteExtension": {
          "type": "string",
          "format": "byte",
          "title": "this extension's signature is replay-protected"
        },
        "nonRpExtension": {
          "type": "string",
          "format": "byte",
          "title": "this extension's signature is _not_ replay-protected"
        }
      },
      "description": "ExtendVoteResponse contains the vote extension that the application would like to\nattach to its next precommit vote.\nInformation in `vote_extension` will be replay-protected.\nInformation in `non_rp_extension` will not be replay-protected."
    },
    "cometbft.abci.v2.ExtendedCommitInfo": {
      "type": "object",
      "properties": {
        "round": {
          "type": "integer",
          "format": "int32",
          "description": "The round at which the block proposer decided in the previous height."
        },
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.ExtendedVoteInfo"
          },
          "description": "List of validators' addresses in the last validator set with their voting\ninformation, including vote extensions."
        }
      },
      "description": "ExtendedCommitInfo is similar to CommitInfo except that it is only used in\nthe PrepareProposal request such that Tendermint can provide vote extensions\nto the application."
    },
    "cometbft.abci.v2.ExtendedVoteInfo": {
      "type": "object",
      "properties": {
        "validator": {
          "$ref": "#/definitions/cometbft.abci.v2.Validator",
          "description": "The validator that sent the vote."
        },
        "voteExtension": {
          "type": "string",
          "format": "byte",
          "description": "Non-deterministic extension provided by the sending validator's application."
        },
        "extensionSignature": {
          "type": "string",
          "format": "byte",
          "title": "Vote extension signature created by CometBFT"
        },
        "blockIdFlag": {
          "$ref": "#/definitions/cometbft.types.v2.BlockIDFlag",
          "title": "block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all"
        },
        "nonRpVoteExtension": {
          "type": "string",
          "format": "byte",
          "description": "Non-deterministic non-replay-protected extension provided by the sending validator's application."
        },
        "nonRpExtensionSignature": {
          "type": "string",
          "format": "byte",
          "title": "Signature on non-replay-protected extension created by CometBFT"
        }
      },
      "description": "ExtendedVoteInfo extends VoteInfo with the vote extensions (non-deterministic)."
    },
    "cometbft.abci.v2.FinalizeBlockResponse": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.Event"
          },
          "description": "nondeterministic",
          "title": "set of block events emitted as part of executing the block"
        },
        "txResults": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.ExecTxResult"
          },
          "title": "the result of executing each transaction including the events\nthe particular transaction emitted. This should match the order\nof the transactions delivered in the block itself"
        },
        "validatorUpdates": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.ValidatorUpdate"
          },
          "description": "a list of updates to the validator set. These will reflect the validator set at current height + 2."
        },
        "consensusParamUpdates": {
          "$ref": "#/definitions/cometbft.types.v2.ConsensusParams",
          "description": "updates to the consensus params, if any."
        },
        "appHash": {
          "type": "string",
          "format": "byte",
          "description": "app_hash is the hash of the applications' state which is used to confirm\nthat execution of the transactions was deterministic.\nIt is up to the application to decide which algorithm to use."
        },
        "nextBlockDelay": {
          "type": "string",
          "title": "delay between the time when this block is committed and the next height is started.\npreviously `timeout_commit` in config.toml"
        }
      },
      "description": "FinalizeBlockResponse contains the result of executing the block."
    },
    "cometbft.abci.v2.FlushResponse": {
      "type": "object",
      "description": "FlushResponse indicates that the write buffer was flushed."
    },
    "cometbft.abci.v2.InfoResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "appVersion": {
          "type": "string",
          "format": "uint64"
        },
        "lastBlockHeight": {
          "type": "string",
          "format": "int64"
        },
        "lastBlockAppHash": {
          "type": "string",
          "format": "byte"
        },
        "lanePriorities": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int64"
          }
        },
        "defaultLane": {
          "type": "string"
        }
      },
      "description": "InfoResponse contains the ABCI application version information."
    },
    "cometbft.abci.v2.InitChainResponse": {
      "type": "object",
      "properties": {
        "consensusParams": {
          "$ref": "#/definitions/cometbft.types.v2.ConsensusParams"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.ValidatorUpdate"
          }
        },
        "appHash": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "InitChainResponse contains the ABCI application's hash and updates to the\nvalidator set and/or the consensus params, if any."
    },
    "cometbft.abci.v2.ListSnapshotsResponse": {
      "type": "object",
      "properties": {
        "snapshots": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.Snapshot"
          }
        }
      },
      "description": "ListSnapshotsResponse contains the list of snapshots."
    },
    "cometbft.abci.v2.LoadSnapshotChunkResponse": {
      "type": "object",
      "properties": {
        "chunk": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "LoadSnapshotChunkResponse returns a snapshot's chunk."
    },
    "cometbft.abci.v2.Misbehavior": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/cometbft.abci.v2.MisbehaviorType"
        },
        "validator": {
          "$ref": "#/definitions/cometbft.abci.v2.Validator",
          "title": "The offending validator"
        },
        "height": {
          "type": "string",
          "format": "int64",
          "title": "The height when the offense occurred"
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "title": "The corresponding time where the offense occurred"
        },
        "totalVotingPower": {
          "type": "string",
          "format": "int64",
          "title": "Total voting power of the validator set in case the ABCI application does\nnot store historical validators.\nhttps://github.com/tendermint/tendermint/issues/4581"
        }
      },
      "description": "Misbehavior is a type of misbehavior committed by a validator."
    },
    "cometbft.abci.v2.MisbehaviorType": {
      "type": "string",
      "enum": [
        "MISBEHAVIOR_TYPE_UNKNOWN",
        "MISBEHAVIOR_TYPE_DUPLICATE_VOTE",
        "MISBEHAVIOR_TYPE_LIGHT_CLIENT_ATTACK"
      ],
      "default": "MISBEHAVIOR_TYPE_UNKNOWN",
      "description": "The type of misbehavior committed by a validator.\n\n - MISBEHAVIOR_TYPE_UNKNOWN: Unknown\n - MISBEHAVIOR_TYPE_DUPLICATE_VOTE: Duplicate vote\n - MISBEHAVIOR_TYPE_LIGHT_CLIENT_ATTACK: Light client attack"
    },
    "cometbft.abci.v2.OfferSnapshotResponse": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/cometbft.abci.v2.OfferSnapshotResult"
        }
      },
      "description": "OfferSnapshotResponse indicates the ABCI application decision whenever to\nprovide a snapshot to the requester or not."
    },
    "cometbft.abci.v2.OfferSnapshotResult": {
      "type": "string",
      "enum": [
        "OFFER_SNAPSHOT_RESULT_UNKNOWN",
        "OFFER_SNAPSHOT_RESULT_ACCEPT",
        "OFFER_SNAPSHOT_RESULT_ABORT",
        "OFFER_SNAPSHOT_RESULT_REJECT",
        "OFFER_SNAPSHOT_RESULT_REJECT_FORMAT",
        "OFFER_SNAPSHOT_RESULT_REJECT_SENDER"
      ],
      "default": "OFFER_SNAPSHOT_RESULT_UNKNOWN",
      "description": "The result of offering a snapshot.\n\n - OFFER_SNAPSHOT_RESULT_UNKNOWN: Unknown result, abort all snapshot restoration\n - OFFER_SNAPSHOT_RESULT_ACCEPT: Snapshot accepted, apply chunks\n - OFFER_SNAPSHOT_RESULT_ABORT: Abort all snapshot restoration\n - OFFER_SNAPSHOT_RESULT_REJECT: Reject this specific snapshot, try others\n - OFFER_SNAPSHOT_RESULT_REJECT_FORMAT: Reject all snapshots of this format, try others\n - OFFER_SNAPSHOT_RESULT_REJECT_SENDER: Reject all snapshots from the sender(s), try others"
    },
    "cometbft.abci.v2.PrepareProposalResponse": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        }
      },
      "description": "PrepareProposalResponse contains a list of transactions, which will form a block."
    },
    "cometbft.abci.v2.ProcessProposalResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/cometbft.abci.v2.ProcessProposalStatus"
        }
      },
      "description": "ProcessProposalResponse indicates the ABCI application's decision whenever\nthe given proposal should be accepted or not."
    },
    "cometbft.abci.v2.ProcessProposalStatus": {
      "type": "string",
      "enum": [
        "PROCESS_PROPOSAL_STATUS_UNKNOWN",
        "PROCESS_PROPOSAL_STATUS_ACCEPT",
        "PROCESS_PROPOSAL_STATUS_REJECT"
      ],
      "default": "PROCESS_PROPOSAL_STATUS_UNKNOWN",
      "description": "ProcessProposalStatus is the status of the proposal processing.\n\n - PROCESS_PROPOSAL_STATUS_UNKNOWN: Unknown\n - PROCESS_PROPOSAL_STATUS_ACCEPT: Accepted\n - PROCESS_PROPOSAL_STATUS_REJECT: Rejected"
    },
    "cometbft.abci.v2.QueryResponse": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "log": {
          "type": "string",
          "description": "bytes data = 2; // use \"value\" instead.\n\nnondeterministic"
        },
        "info": {
          "type": "string",
          "title": "nondeterministic"
        },
        "index": {
          "type": "string",
          "format": "int64"
        },
        "key": {
          "type": "string",
          "format": "byte"
        },
        "value": {
          "type": "string",
          "format": "byte"
        },
        "proofOps": {
          "$ref": "#/definitions/cometbft.crypto.v1.ProofOps"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "codespace": {
          "type": "string"
        }
      },
      "description": "QueryResponse contains the ABCI application data along with a proof."
    },
    "cometbft.abci.v2.Snapshot": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "uint64",
          "title": "The height at which the snapshot was taken"
        },
        "format": {
          "type": "integer",
          "format": "int64",
          "title": "The application-specific snapshot format"
        },
        "chunks": {
          "type": "integer",
          "format": "int64",
          "title": "Number of chunks in the snapshot"
        },
        "hash": {
          "type": "string",
          "format": "byte",
          "title": "Arbitrary snapshot hash, equal only if identical"
        },
        "metadata": {
          "type": "string",
          "format": "byte",
          "title": "Arbitrary application metadata"
        }
      },
      "description": "Snapshot of the ABCI application state."
    },
    "cometbft.abci.v2.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte",
          "title": "The first 20 bytes of SHA256(public key)"
        },
        "power": {
          "type": "string",
          "format": "int64",
          "description": "The voting power",
          "title": "PubKey pub_key = 2 [(gogoproto.nullable)=false];"
        }
      },
      "description": "Validator in the validator set."
    },
    "cometbft.abci.v2.ValidatorUpdate": {
      "type": "object",
      "properties": {
        "power": {
          "type": "string",
          "format": "int64"
        },
        "pubKeyBytes": {
          "type": "string",
          "format": "byte"
        },
        "pubKeyType": {
          "type": "string"
        }
      },
      "description": "ValidatorUpdate is a singular update to a validator set."
    },
    "cometbft.abci.v2.VerifyVoteExtensionResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/cometbft.abci.v2.VerifyVoteExtensionStatus"
        }
      },
      "description": "VerifyVoteExtensionResponse indicates the ABCI application's decision\nwhenever the vote extension should be accepted or not."
    },
    "cometbft.abci.v2.VerifyVoteExtensionStatus": {
      "type": "string",
      "enum": [
        "VERIFY_VOTE_EXTENSION_STATUS_UNKNOWN",
        "VERIFY_VOTE_EXTENSION_STATUS_ACCEPT",
        "VERIFY_VOTE_EXTENSION_STATUS_REJECT"
      ],
      "default": "VERIFY_VOTE_EXTENSION_STATUS_UNKNOWN",
      "description": "VerifyVoteExtensionStatus is the status of the vote extension verification.\n\n - VERIFY_VOTE_EXTENSION_STATUS_UNKNOWN: Unknown\n - VERIFY_VOTE_EXTENSION_STATUS_ACCEPT: Accepted\n - VERIFY_VOTE_EXTENSION_STATUS_REJECT: Rejecting the vote extension will reject the entire precommit by the sender.\nIncorrectly implementing this thus has liveness implications as it may affect\nCometBFT's ability to receive 2/3+ valid votes to finalize the block.\nHonest nodes should never be rejected."
    },
    "cometbft.abci.v2.VoteInfo": {
      "type": "object",
      "properties": {
        "validator": {
          "$ref": "#/definitions/cometbft.abci.v2.Validator"
        },
        "blockIdFlag": {
          "$ref": "#/definitions/cometbft.types.v2.BlockIDFlag"
        }
      },
      "description": "VoteInfo contains the information about the vote."
    },
    "cometbft.crypto.v1.ProofOp": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "key": {
          "type": "string",
          "format": "byte"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "ProofOp defines an operation used for calculating Merkle root\nThe data could be arbitrary format, providing necessary data\nfor example neighbouring node hash"
    },
    "cometbft.crypto.v1.ProofOps": {
      "type": "object",
      "properties": {
        "ops": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.crypto.v1.ProofOp"
          }
        }
      },
      "title": "ProofOps is Merkle proof defined by the list of ProofOps"
    },
    "cometbft.crypto.v1.PublicKey": {
      "type": "object",
      "properties": {
        "ed25519": {
          "type": "string",
          "format": "byte"
        },
        "secp256k1": {
          "type": "string",
          "format": "byte"
        },
        "bls12381": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "PublicKey is a ED25519 or a secp256k1 public key."
    },
    "cometbft.p2p.v1.DefaultNodeInfo": {
      "type": "object",
      "properties": {
        "protocolVersion": {
          "$ref": "#/definitions/cometbft.p2p.v1.ProtocolVersion"
        },
        "defaultNodeId": {
          "type": "string"
        },
        "listenAddr": {
          "type": "string"
        },
        "network": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "channels": {
          "type": "string",
          "format": "byte"
        },
        "moniker": {
          "type": "string"
        },
        "other": {
          "$ref": "#/definitions/cometbft.p2p.v1.DefaultNodeInfoOther"
        }
      },
      "description": "DefaultNodeInfo is a basic node's information sent to other peers during the\np2p handshake."
    },
    "cometbft.p2p.v1.DefaultNodeInfoOther": {
      "type": "object",
      "properties": {
        "txIndex": {
          "type": "string"
        },
        "rpcAddress": {
          "type": "string"
        }
      },
      "description": "DefaultNodeInfoOther is the misc. application specific data."
    },
    "cometbft.p2p.v1.ProtocolVersion": {
      "type": "object",
      "properties": {
        "p2p": {
          "type": "string",
          "format": "uint64"
        },
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "ProtocolVersion represents the current p2p protocol version."
    },
    "cometbft.types.v2.ABCIParams": {
      "type": "object",
      "properties": {
        "voteExtensionsEnableHeight": {
          "type": "string",
          "format": "int64",
          "description": "vote_extensions_enable_height has been deprecated.\nInstead, use FeatureParams.vote_extensions_enable_height."
        }
      },
      "title": "ABCIParams is deprecated and its contents moved to FeatureParams"
    },
    "cometbft.types.v2.Block": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/cometbft.types.v2.Header"
        },
        "data": {
          "$ref": "#/definitions/cometbft.types.v2.Data"
        },
        "evidence": {
          "$ref": "#/definitions/cometbft.types.v2.EvidenceList"
        },
        "lastCommit": {
          "$ref": "#/definitions/cometbft.types.v2.Commit"
        }
      },
      "description": "Block defines the structure of a block in the CometBFT blockchain."
    },
    "cometbft.types.v2.BlockID": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte"
        },
        "partSetHeader": {
          "$ref": "#/definitions/cometbft.types.v2.PartSetHeader"
        }
      },
      "description": "BlockID defines the unique ID of a block as its hash and its `PartSetHeader`."
    },
    "cometbft.types.v2.BlockIDFlag": {
      "type": "string",
      "enum": [
        "BLOCK_ID_FLAG_UNKNOWN",
        "BLOCK_ID_FLAG_ABSENT",
        "BLOCK_ID_FLAG_COMMIT",
        "BLOCK_ID_FLAG_NIL"
      ],
      "default": "BLOCK_ID_FLAG_UNKNOWN",
      "description": "- BLOCK_ID_FLAG_UNKNOWN: Indicates an error condition\n - BLOCK_ID_FLAG_ABSENT: The vote was not received\n - BLOCK_ID_FLAG_COMMIT: Voted for the block that received the majority\n - BLOCK_ID_FLAG_NIL: Voted for nil",
      "title": "BlockIdFlag indicates which BlockID the signature is for"
    },
    "cometbft.types.v2.BlockParams": {
      "type": "object",
      "properties": {
        "maxBytes": {
          "type": "string",
          "format": "int64",
          "description": "Maximum size of a block, in bytes.\n\nMust be greater or equal to -1 and cannot be greater than the hard-coded\nmaximum block size, which is 100MB.\n\nIf set to -1, the limit is the hard-coded maximum block size."
        },
        "maxGas": {
          "type": "string",
          "format": "int64",
          "description": "Maximum gas wanted by transactions included in a block.\n\nMust be greater or equal to -1. If set to -1, no limit is enforced."
        }
      },
      "description": "BlockParams define limits on the block size and gas."
    },
    "cometbft.types.v2.Commit": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64"
        },
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "blockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID"
        },
        "signatures": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.types.v2.CommitSig"
          }
        }
      },
      "description": "Commit contains the evidence that a block was committed by a set of validators."
    },
    "cometbft.types.v2.CommitSig": {
      "type": "object",
      "properties": {
        "blockIdFlag": {
          "$ref": "#/definitions/cometbft.types.v2.BlockIDFlag"
        },
        "validatorAddress": {
          "type": "string",
          "format": "byte"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "signature": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "CommitSig is a part of the Vote included in a Commit."
    },
    "cometbft.types.v2.ConsensusParams": {
      "type": "object",
      "properties": {
        "block": {
          "$ref": "#/definitions/cometbft.types.v2.BlockParams"
        },
        "evidence": {
          "$ref": "#/definitions/cometbft.types.v2.EvidenceParams"
        },
        "validator": {
          "$ref": "#/definitions/cometbft.types.v2.ValidatorParams"
        },
        "version": {
          "$ref": "#/definitions/cometbft.types.v2.VersionParams"
        },
        "abci": {
          "$ref": "#/definitions/cometbft.types.v2.ABCIParams",
          "title": "Use FeatureParams.vote_extensions_enable_height instead"
        },
        "synchrony": {
          "$ref": "#/definitions/cometbft.types.v2.SynchronyParams"
        },
        "feature": {
          "$ref": "#/definitions/cometbft.types.v2.FeatureParams"
        }
      },
      "description": "ConsensusParams contains consensus critical parameters that determine the\nvalidity of blocks."
    },
    "cometbft.types.v2.Data": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
        }
      },
      "title": "Data contains the set of transactions included in the block"
    },
    "cometbft.types.v2.DuplicateVoteEvidence": {
      "type": "object",
      "properties": {
        "voteA": {
          "$ref": "#/definitions/cometbft.types.v2.Vote"
        },
        "voteB": {
          "$ref": "#/definitions/cometbft.types.v2.Vote"
        },
        "totalVotingPower": {
          "type": "string",
          "format": "int64"
        },
        "validatorPower": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
    },
    "cometbft.types.v2.Evidence": {
      "type": "object",
      "properties": {
        "duplicateVoteEvidence": {
          "$ref": "#/definitions/cometbft.types.v2.DuplicateVoteEvidence"
        },
        "lightClientAttackEvidence": {
          "$ref": "#/definitions/cometbft.types.v2.LightClientAttackEvidence"
        }
      },
      "description": "Evidence is a generic type for wrapping evidence of misbehavior by a validator."
    },
    "cometbft.types.v2.EvidenceList": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.types.v2.Evidence"
          }
        }
      },
      "description": "EvidenceList is a list of evidence."
    },
    "cometbft.types.v2.EvidenceParams": {
      "type": "object",
      "properties": {
        "maxAgeNumBlocks": {
          "type": "string",
          "format": "int64",
          "description": "Maximum age of evidence, in blocks.\n\nThe recommended formula for calculating it is max_age_duration / {average\nblock time}."
        },
        "maxAgeDuration": {
          "type": "string",
          "description": "Maximum age of evidence, in time.\n\nThe recommended value of is should correspond to the application's\n\"unbonding period\" or other similar mechanism for handling\nNothing-At-Stake attacks.\nSee:\nhttps://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed."
        },
        "maxBytes": {
          "type": "string",
          "format": "int64",
          "description": "Maximum size in bytes of evidence allowed to be included in a block.\n\nIt should fall comfortably under the maximum size of a block."
        }
      },
      "description": "EvidenceParams determine the validity of evidences of Byzantine behavior."
    },
    "cometbft.types.v2.FeatureParams": {
      "type": "object",
      "properties": {
        "voteExtensionsEnableHeight": {
          "type": "string",
          "format": "int64",
          "description": "Height during which vote extensions will be enabled.\n\nA value of 0 means vote extensions are disabled. A value > 0 denotes\nthe height at which vote extensions will be (or have been) enabled.\n\nDuring the specified height, and for all subsequent heights, precommit\nmessages that do not contain valid extension data will be considered\ninvalid. Prior to this height, or when this height is set to 0, vote\nextensions will not be used or accepted by validators on the network.\n\nOnce enabled, vote extensions will be created by the application in\nExtendVote, validated by the application in VerifyVoteExtension, and\nused by the application in PrepareProposal, when proposing the next block.\n\nCannot be set to heights lower or equal to the current blockchain height."
        },
        "pbtsEnableHeight": {
          "type": "string",
          "format": "int64",
          "description": "Height at which Proposer-Based Timestamps (PBTS) will be enabled.\n\nA value of 0 means PBTS is disabled. A value > 0 denotes the height at\nwhich PBTS will be (or has been) enabled.\n\nFrom the specified height, and for all subsequent heights, the PBTS\nalgorithm will be used to produce and validate block timestamps. Prior to\nthis height, or when this height is set to 0, the legacy BFT Time\nalgorithm is used to produce and validate timestamps.\n\nCannot be set to heights lower or equal to the current blockchain height."
        }
      },
      "description": "FeatureParams configure the height from which features of CometBFT are enabled."
    },
    "cometbft.types.v2.Header": {
      "type": "object",
      "properties": {
        "version": {
          "$ref": "#/definitions/cometbft.version.v1.Consensus",
          "title": "basic block info"
        },
        "chainId": {
          "type": "string"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "lastBlockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID",
          "title": "prev block info"
        },
        "lastCommitHash": {
          "type": "string",
          "format": "byte",
          "description": "commit from validators from the last block",
          "title": "hashes of block data"
        },
        "dataHash": {
          "type": "string",
          "format": "byte",
          "title": "transactions"
        },
        "validatorsHash": {
          "type": "string",
          "format": "byte",
          "description": "validators for the current block",
          "title": "hashes from the app output from the prev block"
        },
        "nextValidatorsHash": {
          "type": "string",
          "format": "byte",
          "title": "validators for the next block"
        },
        "consensusHash": {
          "type": "string",
          "format": "byte",
          "title": "consensus params for current block"
        },
        "appHash": {
          "type": "string",
          "format": "byte",
          "title": "state after txs from the previous block"
        },
        "lastResultsHash": {
          "type": "string",
          "format": "byte",
          "title": "root hash of all results from the txs from the previous block"
        },
        "evidenceHash": {
          "type": "string",
          "format": "byte",
          "description": "evidence included in the block",
          "title": "consensus info"
        },
        "proposerAddress": {
          "type": "string",
          "format": "byte",
          "title": "original proposer of the block"
        }
      },
      "description": "Header defines the structure of a block header."
    },
    "cometbft.types.v2.LightBlock": {
      "type": "object",
      "properties": {
        "signedHeader": {
          "$ref": "#/definitions/cometbft.types.v2.SignedHeader"
        },
        "validatorSet": {
          "$ref": "#/definitions/cometbft.types.v2.ValidatorSet"
        }
      },
      "description": "LightBlock is a combination of SignedHeader and ValidatorSet. It is used by light clients."
    },
    "cometbft.types.v2.LightClientAttackEvidence": {
      "type": "object",
      "properties": {
        "conflictingBlock": {
          "$ref": "#/definitions/cometbft.types.v2.LightBlock"
        },
        "commonHeight": {
          "type": "string",
          "format": "int64"
        },
        "byzantineValidators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.types.v2.Validator"
          }
        },
        "totalVotingPower": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
    },
    "cometbft.types.v2.PartSetHeader": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "format": "int64"
        },
        "hash": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Header of the parts set for a block."
    },
    "cometbft.types.v2.SignedHeader": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/cometbft.types.v2.Header"
        },
        "commit": {
          "$ref": "#/definitions/cometbft.types.v2.Commit"
        }
      },
      "description": "SignedHeader contains a Header(H) and Commit(H+1) with signatures of validators who signed it."
    },
    "cometbft.types.v2.SignedMsgType": {
      "type": "string",
      "enum": [
        "SIGNED_MSG_TYPE_UNKNOWN",
        "SIGNED_MSG_TYPE_PREVOTE",
        "SIGNED_MSG_TYPE_PRECOMMIT",
        "SIGNED_MSG_TYPE_PROPOSAL"
      ],
      "default": "SIGNED_MSG_TYPE_UNKNOWN",
      "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_UNKNOWN: Unknown\n - SIGNED_MSG_TYPE_PREVOTE: Prevote\n - SIGNED_MSG_TYPE_PRECOMMIT: Precommit\n - SIGNED_MSG_TYPE_PROPOSAL: Proposal"
    },
    "cometbft.types.v2.SynchronyParams": {
      "type": "object",
      "properties": {
        "precision": {
          "type": "string",
          "description": "Bound for how skewed a proposer's clock may be from any validator on the\nnetwork while still producing valid proposals."
        },
        "messageDelay": {
          "type": "string",
          "description": "Bound for how long a proposal message may take to reach all validators on\na network and still be considered valid."
        }
      },
      "description": "SynchronyParams determine the validity of block timestamps.\n\nThese parameters are part of the Proposer-Based Timestamps (PBTS) algorithm.\nFor more information on the relationship of the synchrony parameters to\nblock timestamps validity, refer to the PBTS specification:\nhttps://github.com/tendermint/spec/blob/master/spec/consensus/proposer-based-timestamp/README.md"
    },
    "cometbft.types.v2.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "pubKey": {
          "$ref": "#/definitions/cometbft.crypto.v1.PublicKey"
        },
        "votingPower": {
          "type": "string",
          "format": "int64"
        },
        "proposerPriority": {
          "type": "string",
          "format": "int64"
        },
        "pubKeyBytes": {
          "type": "string",
          "format": "byte"
        },
        "pubKeyType": {
          "type": "string"
        }
      },
      "description": "Validator represents a node participating in the consensus protocol."
    },
    "cometbft.types.v2.ValidatorParams": {
      "type": "object",
      "properties": {
        "pubKeyTypes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "ValidatorParams restrict the public key types validators can use.\n\nNOTE: uses ABCI public keys naming, not Amino names."
    },
    "cometbft.types.v2.ValidatorSet": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.types.v2.Validator"
          }
        },
        "proposer": {
          "$ref": "#/definitions/cometbft.types.v2.Validator"
        },
        "totalVotingPower": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "ValidatorSet defines a set of validators."
    },
    "cometbft.types.v2.VersionParams": {
      "type": "object",
      "properties": {
        "app": {
          "type": "string",
          "format": "uint64",
          "description": "The ABCI application version.\n\nIt was named app_version in CometBFT 0.34."
        }
      },
      "description": "VersionParams contain the version of specific components of CometBFT."
    },
    "cometbft.types.v2.Vote": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/cometbft.types.v2.SignedMsgType"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "blockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID",
          "description": "zero if vote is nil."
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "validatorAddress": {
          "type": "string",
          "format": "byte"
        },
        "validatorIndex": {
          "type": "integer",
          "format": "int32"
        },
        "signature": {
          "type": "string",
          "format": "byte",
          "description": "Vote signature by the validator if they participated in consensus for the\nassociated block."
        },
        "extension": {
          "type": "string",
          "format": "byte",
          "description": "Vote extension provided by the application. Only valid for precommit\nmessages."
        },
        "extensionSignature": {
          "type": "string",
          "format": "byte",
          "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages."
        },
        "nonRpExtension": {
          "type": "string",
          "format": "byte",
          "description": "Non-Replay-Protected (NRP) vote extension provided by the application.\nOnly valid for precommit messages."
        },
        "nonRpExtensionSignature": {
          "type": "string",
          "format": "byte",
          "description": "Non-Replay-Protected (NRP) vote extension signature by the validator if\nthey participated in consensus for the associated block.\nOnly valid for precommit messages."
        }
      },
      "description": "Vote represents a prevote or precommit vote from validators for\nconsensus.\nFor precommit messages, the message contains vote extensions (replay-protected and non-replay-protected)\nand their signatures."
    },
    "cometbft.version.v1.Consensus": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
    },
    "cosmos.app.v1alpha1.Config": {
      "type": "object",
      "properties": {
        "modules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.app.v1alpha1.ModuleConfig"
          },
          "description": "modules are the module configurations for the app."
        },
        "golangBindings": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.app.v1alpha1.GolangBinding"
          },
          "description": "golang_bindings specifies explicit interface to implementation type bindings which\ndepinject uses to resolve interface inputs to provider functions.  The scope of this\nfield's configuration is global (not module specific)."
        }
      },
      "description": "Config represents the configuration for a Cosmos SDK ABCI app.\nIt is intended that all state machine logic including the version of\nbaseapp and tx handlers (and possibly even Tendermint) that an app needs\ncan be described in a config object. For compatibility, the framework should\nallow a mixture of declarative and imperative app wiring, however, apps\nthat strive for the maximum ease of maintainability should be able to describe\ntheir state machine with a config object alone."
    },
    "cosmos.app.v1alpha1.GolangBinding": {
      "type": "object",
      "properties": {
        "interfaceType": {
          "type": "string",
          "title": "interface_type is the interface type which will be bound to a specific implementation type"
        },
        "implementation": {
          "type": "string",
          "title": "implementation is the implementing type which will be supplied when an input of type interface is requested"
        }
      },
      "description": "GolangBinding is an explicit interface type to implementing type binding for dependency injection."
    },
    "cosmos.app.v1alpha1.ModuleConfig": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name is the unique name of the module within the app. It should be a name\nthat persists between different versions of a module so that modules\ncan be smoothly upgraded to new versions.\n\nFor example, for the module cosmos.bank.module.v1.Module, we may chose\nto simply name the module \"bank\" in the app. When we upgrade to\ncosmos.bank.module.v2.Module, the app-specific name \"bank\" stays the same\nand the framework knows that the v2 module should receive all the same state\nthat the v1 module had. Note: modules should provide info on which versions\nthey can migrate from in the ModuleDescriptor.can_migration_from field."
        },
        "config": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "config is the config object for the module. Module config messages should\ndefine a ModuleDescriptor using the cosmos.app.v1alpha1.is_module extension."
        },
        "golangBindings": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.app.v1alpha1.GolangBinding"
          },
          "description": "golang_bindings specifies explicit interface to implementation type bindings which\ndepinject uses to resolve interface inputs to provider functions.  The scope of this\nfield's configuration is module specific."
        }
      },
      "description": "ModuleConfig is a module configuration for an app."
    },
    "cosmos.app.v1alpha1.QueryConfigResponse": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/cosmos.app.v1alpha1.Config",
          "description": "config is the current app config."
        }
      },
      "description": "QueryConfigResponse is the Query/Config response type."
    },
    "cosmos.auth.v1beta1.AddressBytesToStringResponse": {
      "type": "object",
      "properties": {
        "addressString": {
          "type": "string"
        }
      },
      "description": "AddressBytesToStringResponse is the response type for AddressString rpc method."
    },
    "cosmos.auth.v1beta1.AddressStringToBytesResponse": {
      "type": "object",
      "properties": {
        "addressBytes": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "AddressStringToBytesResponse is the response type for AddressBytes rpc method."
    },
    "cosmos.auth.v1beta1.BaseAccount": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "pubKey": {
          "$ref": "#/definitions/google.protobuf.Any"
        },
        "accountNumber": {
          "type": "string",
          "format": "uint64"
        },
        "sequence": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "BaseAccount defines a base account type. It contains all the necessary fields\nfor basic account functionality. Any custom account type should extend this\ntype for additional functionality (e.g. vesting)."
    },
    "cosmos.auth.v1beta1.Bech32PrefixResponse": {
      "type": "object",
      "properties": {
        "bech32Prefix": {
          "type": "string"
        }
      },
      "description": "Bech32PrefixResponse is the response type for Bech32Prefix rpc method."
    },
    "cosmos.auth.v1beta1.Params": {
      "type": "object",
      "properties": {
        "maxMemoCharacters": {
          "type": "string",
          "format": "uint64"
        },
        "txSigLimit": {
          "type": "string",
          "format": "uint64"
        },
        "txSizeCostPerByte": {
          "type": "string",
          "format": "uint64"
        },
        "sigVerifyCostEd25519": {
          "type": "string",
          "format": "uint64"
        },
        "sigVerifyCostSecp256k1": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Params defines the parameters for the auth module."
    },
    "cosmos.auth.v1beta1.QueryAccountAddressByIDResponse": {
      "type": "object",
      "properties": {
        "accountAddress": {
          "type": "string"
        }
      },
      "title": "QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method"
    },
    "cosmos.auth.v1beta1.QueryAccountInfoResponse": {
      "type": "object",
      "properties": {
        "info": {
          "$ref": "#/definitions/cosmos.auth.v1beta1.BaseAccount",
          "description": "info is the account info which is represented by BaseAccount."
        }
      },
      "description": "QueryAccountInfoResponse is the Query/AccountInfo response type."
    },
    "cosmos.auth.v1beta1.QueryAccountResponse": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "account defines the account of the corresponding address."
        }
      },
      "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
    },
    "cosmos.auth.v1beta1.QueryAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "title": "accounts are the existing accounts"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method."
    },
    "cosmos.auth.v1beta1.QueryModuleAccountByNameResponse": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/google.protobuf.Any"
        }
      },
      "description": "QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."
    },
    "cosmos.auth.v1beta1.QueryModuleAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          }
        }
      },
      "description": "QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method."
    },
    "cosmos.auth.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.auth.v1beta1.Params",
          "description": "params defines the parameters of the module."
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.authz.v1beta1.Grant": {
      "type": "object",
      "properties": {
        "authorization": {
          "$ref": "#/definitions/google.protobuf.Any"
        },
        "expiration": {
          "type": "string",
          "format": "date-time",
          "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)"
        }
      },
      "description": "Grant gives permissions to execute\nthe provide method with expiration time."
    },
    "cosmos.authz.v1beta1.GrantAuthorization": {
      "type": "object",
      "properties": {
        "granter": {
          "type": "string"
        },
        "grantee": {
          "type": "string"
        },
        "authorization": {
          "$ref": "#/definitions/google.protobuf.Any"
        },
        "expiration": {
          "type": "string",
          "format": "date-time"
        }
      },
      "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto"
    },
    "cosmos.authz.v1beta1.QueryGranteeGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.authz.v1beta1.GrantAuthorization"
          },
          "description": "grants is a list of grants granted to the grantee."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."
    },
    "cosmos.authz.v1beta1.QueryGranterGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.authz.v1beta1.GrantAuthorization"
          },
          "description": "grants is a list of grants granted by the granter."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."
    },
    "cosmos.authz.v1beta1.QueryGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.authz.v1beta1.Grant"
          },
          "description": "authorizations is a list of grants granted for grantee by granter."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
    },
    "cosmos.autocli.v1.AppOptionsResponse": {
      "type": "object",
      "properties": {
        "moduleOptions": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/cosmos.autocli.v1.ModuleOptions"
          },
          "description": "module_options is a map of module name to autocli module options."
        }
      },
      "description": "AppOptionsResponse is the RemoteInfoService/AppOptions response type."
    },
    "cosmos.autocli.v1.FlagOptions": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name is an alternate name to use for the field flag."
        },
        "shorthand": {
          "type": "string",
          "description": "shorthand is a one-letter abbreviated flag."
        },
        "usage": {
          "type": "string",
          "description": "usage is the help message."
        },
        "defaultValue": {
          "type": "string",
          "description": "default_value is the default value as text."
        },
        "deprecated": {
          "type": "string",
          "description": "deprecated is the usage text to show if this flag is deprecated."
        },
        "shorthandDeprecated": {
          "type": "string",
          "description": "shorthand_deprecated is the usage text to show if the shorthand of this flag is deprecated."
        },
        "hidden": {
          "type": "boolean",
          "title": "hidden hides the flag from help/usage text"
        }
      },
      "description": "FlagOptions are options for flags generated from rpc request fields.\nBy default, all request fields are configured as flags based on the\nkebab-case name of the field. Fields can be turned into positional arguments\ninstead by using RpcCommandOptions.positional_args."
    },
    "cosmos.autocli.v1.ModuleOptions": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.autocli.v1.ServiceCommandDescriptor",
          "description": "tx describes the tx commands for the module."
        },
        "query": {
          "$ref": "#/definitions/cosmos.autocli.v1.ServiceCommandDescriptor",
          "description": "query describes the queries commands for the module."
        }
      },
      "description": "ModuleOptions describes the CLI options for a Cosmos SDK module."
    },
    "cosmos.autocli.v1.PositionalArgDescriptor": {
      "type": "object",
      "properties": {
        "protoField": {
          "type": "string",
          "description": "proto_field specifies the proto field to use as the positional arg. Any\nfields used as positional args will not have a flag generated."
        },
        "varargs": {
          "type": "boolean",
          "description": "varargs makes a positional parameter a varargs parameter. This can only be\napplied to last positional parameter and the proto_field must a repeated\nfield. Note: It is mutually exclusive with optional."
        },
        "optional": {
          "type": "boolean",
          "description": "optional makes the last positional parameter optional.\nNote: It is mutually exclusive with varargs."
        }
      },
      "description": "PositionalArgDescriptor describes a positional argument."
    },
    "cosmos.autocli.v1.RpcCommandOptions": {
      "type": "object",
      "properties": {
        "rpcMethod": {
          "type": "string",
          "description": "rpc_method is short name of the protobuf rpc method that this command is\ngenerated from."
        },
        "use": {
          "type": "string",
          "description": "use is the one-line usage method. It also allows specifying an alternate\nname for the command as the first word of the usage text.\n\nBy default the name of an rpc command is the kebab-case short name of the\nrpc method."
        },
        "long": {
          "type": "string",
          "description": "long is the long message shown in the 'help <this-command>' output."
        },
        "short": {
          "type": "string",
          "description": "short is the short description shown in the 'help' output."
        },
        "example": {
          "type": "string",
          "description": "example is examples of how to use the command."
        },
        "alias": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "alias is an array of aliases that can be used instead of the first word in Use."
        },
        "suggestFor": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "suggest_for is an array of command names for which this command will be suggested -\nsimilar to aliases but only suggests."
        },
        "deprecated": {
          "type": "string",
          "description": "deprecated defines, if this command is deprecated and should print this string when used."
        },
        "version": {
          "type": "string",
          "description": "version defines the version for this command. If this value is non-empty and the command does not\ndefine a \"version\" flag, a \"version\" boolean flag will be added to the command and, if specified,\nwill print content of the \"Version\" variable. A shorthand \"v\" flag will also be added if the\ncommand does not define one."
        },
        "flagOptions": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/cosmos.autocli.v1.FlagOptions"
          },
          "description": "flag_options are options for flags generated from rpc request fields.\nBy default all request fields are configured as flags. They can\nalso be configured as positional args instead using positional_args."
        },
        "positionalArgs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.autocli.v1.PositionalArgDescriptor"
          },
          "description": "positional_args specifies positional arguments for the command."
        },
        "skip": {
          "type": "boolean",
          "description": "skip specifies whether to skip this rpc method when generating commands."
        },
        "govProposal": {
          "type": "boolean",
          "description": "gov_proposal specifies whether autocli should generate a gov proposal transaction for this rpc method.\nNormally autocli generates a transaction containing the message and broadcast it.\nHowever, when true, autocli generates a proposal transaction containing the message and broadcast it.\nThis option is ineffective for query commands."
        }
      },
      "description": "RpcCommandOptions specifies options for commands generated from protobuf\nrpc methods."
    },
    "cosmos.autocli.v1.ServiceCommandDescriptor": {
      "type": "object",
      "properties": {
        "service": {
          "type": "string",
          "description": "service is the fully qualified name of the protobuf service to build\nthe command from. It can be left empty if sub_commands are used instead\nwhich may be the case if a module provides multiple tx and/or query services."
        },
        "rpcCommandOptions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.autocli.v1.RpcCommandOptions"
          },
          "description": "rpc_command_options are options for commands generated from rpc methods.\nIf no options are specified for a given rpc method on the service, a\ncommand will be generated for that method with the default options."
        },
        "subCommands": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/cosmos.autocli.v1.ServiceCommandDescriptor"
          },
          "description": "sub_commands is a map of optional sub-commands for this command based on\ndifferent protobuf services. The map key is used as the name of the\nsub-command."
        },
        "enhanceCustomCommand": {
          "type": "boolean",
          "description": "enhance_custom_commands specifies whether to skip the service when generating commands, if a custom command already\nexists, or enhance the existing command. If set to true, the custom command will be enhanced with the services from\ngRPC. otherwise when a custom command exists, no commands will be generated for the service."
        },
        "short": {
          "type": "string",
          "description": "short is an optional parameter used to override the short description of the auto generated command."
        }
      },
      "description": "ServiceCommandDescriptor describes a CLI command based on a protobuf service."
    },
    "cosmos.bank.v1beta1.DenomOwner": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "address defines the address that owns a particular denomination."
        },
        "balance": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "description": "balance is the balance of the denominated coin for an account."
        }
      },
      "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token."
    },
    "cosmos.bank.v1beta1.DenomUnit": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom represents the string name of the given denom unit (e.g uatom)."
        },
        "exponent": {
          "type": "integer",
          "format": "int64",
          "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
        },
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "aliases is a list of string aliases for the given denom"
        }
      },
      "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
    },
    "cosmos.bank.v1beta1.Metadata": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "denomUnits": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.bank.v1beta1.DenomUnit"
          },
          "title": "denom_units represents the list of DenomUnit's for a given coin"
        },
        "base": {
          "type": "string",
          "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
        },
        "display": {
          "type": "string",
          "description": "display indicates the suggested denom that should be\ndisplayed in clients."
        },
        "name": {
          "type": "string",
          "title": "name defines the name of the token (eg: Cosmos Atom)"
        },
        "symbol": {
          "type": "string",
          "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display."
        },
        "uri": {
          "type": "string",
          "description": "URI to a document (on or off-chain) that contains additional information. Optional."
        },
        "uriHash": {
          "type": "string",
          "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional."
        }
      },
      "description": "Metadata represents a struct that describes\na basic token."
    },
    "cosmos.bank.v1beta1.Params": {
      "type": "object",
      "properties": {
        "sendEnabled": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.bank.v1beta1.SendEnabled"
          },
          "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."
        },
        "defaultSendEnabled": {
          "type": "boolean"
        }
      },
      "description": "Params defines the parameters for the bank module."
    },
    "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "balances is the balances of all the coins."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "description": "balance is the balance of the coin."
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/cosmos.bank.v1beta1.Metadata",
          "description": "metadata describes and provides all the client information for the requested token."
        }
      },
      "description": "QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC\nmethod. Identical with QueryDenomMetadataResponse but receives denom as query string in request."
    },
    "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/cosmos.bank.v1beta1.Metadata",
          "description": "metadata describes and provides all the client information for the requested token."
        }
      },
      "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse": {
      "type": "object",
      "properties": {
        "denomOwners": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.bank.v1beta1.DenomOwner"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDenomOwnersByQueryResponse defines the RPC response of a DenomOwnersByQuery RPC query."
    },
    "cosmos.bank.v1beta1.QueryDenomOwnersResponse": {
      "type": "object",
      "properties": {
        "denomOwners": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.bank.v1beta1.DenomOwner"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query."
    },
    "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
      "type": "object",
      "properties": {
        "metadatas": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.bank.v1beta1.Metadata"
          },
          "description": "metadata provides the client information for all the registered tokens."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.bank.v1beta1.Params",
          "description": "params provides the parameters of the bank module."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
    },
    "cosmos.bank.v1beta1.QuerySendEnabledResponse": {
      "type": "object",
      "properties": {
        "sendEnabled": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.bank.v1beta1.SendEnabled"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response. This field is only\npopulated if the denoms field in the request is empty."
        }
      },
      "description": "QuerySendEnabledResponse defines the RPC response of a SendEnable query."
    },
    "cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "description": "balance is the balance of the coin."
        }
      },
      "description": "QuerySpendableBalanceByDenomResponse defines the gRPC response structure for\nquerying an account's spendable balance for a specific denom."
    },
    "cosmos.bank.v1beta1.QuerySpendableBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "balances is the spendable balances of all the coins."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QuerySpendableBalancesResponse defines the gRPC response structure for querying\nan account's spendable balances."
    },
    "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "description": "amount is the supply of the coin."
        }
      },
      "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
    },
    "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
      "type": "object",
      "properties": {
        "supply": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "supply is the supply of the coins"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod"
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
    },
    "cosmos.base.abci.v1beta1.ABCIMessageLog": {
      "type": "object",
      "properties": {
        "msgIndex": {
          "type": "integer",
          "format": "int64"
        },
        "log": {
          "type": "string"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.abci.v1beta1.StringEvent"
          },
          "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
        }
      },
      "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
    },
    "cosmos.base.abci.v1beta1.Attribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
    },
    "cosmos.base.abci.v1beta1.GasInfo": {
      "type": "object",
      "properties": {
        "gasWanted": {
          "type": "string",
          "format": "uint64",
          "description": "GasWanted is the maximum units of work we allow this tx to perform."
        },
        "gasUsed": {
          "type": "string",
          "format": "uint64",
          "description": "GasUsed is the amount of gas actually consumed."
        }
      },
      "description": "GasInfo defines tx execution gas context."
    },
    "cosmos.base.abci.v1beta1.Result": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL."
        },
        "log": {
          "type": "string",
          "description": "Log contains the log information from message or handler execution."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.Event"
          },
          "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
        },
        "msgResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "description": "msg_responses contains the Msg handler responses type packed in Anys."
        }
      },
      "description": "Result is the union of ResponseFormat and ResponseCheckTx."
    },
    "cosmos.base.abci.v1beta1.StringEvent": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.abci.v1beta1.Attribute"
          }
        }
      },
      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
    },
    "cosmos.base.abci.v1beta1.TxResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "title": "The block height"
        },
        "txhash": {
          "type": "string",
          "description": "The transaction hash."
        },
        "codespace": {
          "type": "string",
          "title": "Namespace for the Code"
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Response code."
        },
        "data": {
          "type": "string",
          "description": "Result bytes, if any."
        },
        "rawLog": {
          "type": "string",
          "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
        },
        "logs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.abci.v1beta1.ABCIMessageLog"
          },
          "description": "The output of the application's logger (typed). May be non-deterministic."
        },
        "info": {
          "type": "string",
          "description": "Additional information. May be non-deterministic."
        },
        "gasWanted": {
          "type": "string",
          "format": "int64",
          "description": "Amount of gas requested for transaction."
        },
        "gasUsed": {
          "type": "string",
          "format": "int64",
          "description": "Amount of gas consumed by transaction."
        },
        "tx": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "The request transaction bytes."
        },
        "timestamp": {
          "type": "string",
          "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cometbft.abci.v2.Event"
          },
          "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages."
        }
      },
      "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
    },
    "cosmos.base.node.v1beta1.ConfigResponse": {
      "type": "object",
      "properties": {
        "minimumGasPrice": {
          "type": "string"
        },
        "pruningKeepRecent": {
          "type": "string"
        },
        "pruningInterval": {
          "type": "string"
        },
        "haltHeight": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "ConfigResponse defines the response structure for the Config gRPC query."
    },
    "cosmos.base.node.v1beta1.StatusResponse": {
      "type": "object",
      "properties": {
        "earliestStoreHeight": {
          "type": "string",
          "format": "uint64",
          "title": "earliest block height available in the store"
        },
        "height": {
          "type": "string",
          "format": "uint64",
          "title": "current block height"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "title": "block height timestamp"
        },
        "appHash": {
          "type": "string",
          "format": "byte",
          "title": "app hash of the current block"
        },
        "validatorHash": {
          "type": "string",
          "format": "byte",
          "title": "validator hash provided by the consensus header"
        }
      },
      "description": "StateResponse defines the response structure for the status of a node."
    },
    "cosmos.base.query.v1beta1.PageRequest": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "format": "byte",
          "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set."
        },
        "offset": {
          "type": "string",
          "format": "uint64",
          "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set."
        },
        "limit": {
          "type": "string",
          "format": "uint64",
          "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app."
        },
        "countTotal": {
          "type": "boolean",
          "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set."
        },
        "reverse": {
          "type": "boolean",
          "description": "reverse is set to true if results are to be returned in the descending order."
        }
      },
      "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }",
      "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:"
    },
    "cosmos.base.query.v1beta1.PageResponse": {
      "type": "object",
      "properties": {
        "nextKey": {
          "type": "string",
          "format": "byte",
          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
        },
        "total": {
          "type": "string",
          "format": "uint64",
          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
        }
      },
      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
    },
    "cosmos.base.tendermint.v1beta1.ABCIQueryResponse": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "log": {
          "type": "string",
          "title": "nondeterministic"
        },
        "info": {
          "type": "string",
          "title": "nondeterministic"
        },
        "index": {
          "type": "string",
          "format": "int64"
        },
        "key": {
          "type": "string",
          "format": "byte"
        },
        "value": {
          "type": "string",
          "format": "byte"
        },
        "proofOps": {
          "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.ProofOps"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "codespace": {
          "type": "string"
        }
      },
      "description": "ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.\n\nNote: This type is a duplicate of the ResponseQuery proto type defined in\nTendermint."
    },
    "cosmos.base.tendermint.v1beta1.Block": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.Header"
        },
        "data": {
          "$ref": "#/definitions/cometbft.types.v2.Data"
        },
        "evidence": {
          "$ref": "#/definitions/cometbft.types.v2.EvidenceList"
        },
        "lastCommit": {
          "$ref": "#/definitions/cometbft.types.v2.Commit"
        }
      },
      "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
    },
    "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
      "type": "object",
      "properties": {
        "blockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID"
        },
        "block": {
          "$ref": "#/definitions/cometbft.types.v2.Block",
          "title": "Deprecated: please use `sdk_block` instead"
        },
        "sdkBlock": {
          "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.Block"
        }
      },
      "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
      "type": "object",
      "properties": {
        "blockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID"
        },
        "block": {
          "$ref": "#/definitions/cometbft.types.v2.Block",
          "title": "Deprecated: please use `sdk_block` instead"
        },
        "sdkBlock": {
          "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.Block"
        }
      },
      "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
      "type": "object",
      "properties": {
        "blockHeight": {
          "type": "string",
          "format": "int64"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.Validator"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
      "type": "object",
      "properties": {
        "defaultNodeInfo": {
          "$ref": "#/definitions/cometbft.p2p.v1.DefaultNodeInfo"
        },
        "applicationVersion": {
          "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.VersionInfo"
        }
      },
      "description": "GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
      "type": "object",
      "properties": {
        "syncing": {
          "type": "boolean"
        }
      },
      "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
      "type": "object",
      "properties": {
        "blockHeight": {
          "type": "string",
          "format": "int64"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.Validator"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.Header": {
      "type": "object",
      "properties": {
        "version": {
          "$ref": "#/definitions/cometbft.version.v1.Consensus",
          "title": "basic block info"
        },
        "chainId": {
          "type": "string"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "lastBlockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID",
          "title": "prev block info"
        },
        "lastCommitHash": {
          "type": "string",
          "format": "byte",
          "description": "commit from validators from the last block",
          "title": "hashes of block data"
        },
        "dataHash": {
          "type": "string",
          "format": "byte",
          "title": "transactions"
        },
        "validatorsHash": {
          "type": "string",
          "format": "byte",
          "description": "validators for the current block",
          "title": "hashes from the app output from the prev block"
        },
        "nextValidatorsHash": {
          "type": "string",
          "format": "byte",
          "title": "validators for the next block"
        },
        "consensusHash": {
          "type": "string",
          "format": "byte",
          "title": "consensus params for current block"
        },
        "appHash": {
          "type": "string",
          "format": "byte",
          "title": "state after txs from the previous block"
        },
        "lastResultsHash": {
          "type": "string",
          "format": "byte",
          "title": "root hash of all results from the txs from the previous block"
        },
        "evidenceHash": {
          "type": "string",
          "format": "byte",
          "description": "evidence included in the block",
          "title": "consensus info"
        },
        "proposerAddress": {
          "type": "string",
          "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX.\n\noriginal proposer of the block"
        }
      },
      "description": "Header defines the structure of a Tendermint block header."
    },
    "cosmos.base.tendermint.v1beta1.Module": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "title": "module path"
        },
        "version": {
          "type": "string",
          "title": "module version"
        },
        "sum": {
          "type": "string",
          "title": "checksum"
        }
      },
      "title": "Module is the type for VersionInfo"
    },
    "cosmos.base.tendermint.v1beta1.ProofOp": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "key": {
          "type": "string",
          "format": "byte"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
    },
    "cosmos.base.tendermint.v1beta1.ProofOps": {
      "type": "object",
      "properties": {
        "ops": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.ProofOp"
          }
        }
      },
      "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
    },
    "cosmos.base.tendermint.v1beta1.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "pubKey": {
          "$ref": "#/definitions/google.protobuf.Any"
        },
        "votingPower": {
          "type": "string",
          "format": "int64"
        },
        "proposerPriority": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "Validator is the type for the validator-set."
    },
    "cosmos.base.tendermint.v1beta1.VersionInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "appName": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "gitCommit": {
          "type": "string"
        },
        "buildTags": {
          "type": "string"
        },
        "goVersion": {
          "type": "string"
        },
        "buildDeps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.tendermint.v1beta1.Module"
          }
        },
        "cosmosSdkVersion": {
          "type": "string"
        }
      },
      "description": "VersionInfo is the type for the GetNodeInfoResponse message."
    },
    "cosmos.base.v1beta1.Coin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
    },
    "cosmos.base.v1beta1.DecCoin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
    },
    "cosmos.circuit.v1.AccountResponse": {
      "type": "object",
      "properties": {
        "permission": {
          "$ref": "#/definitions/cosmos.circuit.v1.Permissions"
        }
      },
      "description": "AccountResponse is the response type for the Query/Account RPC method."
    },
    "cosmos.circuit.v1.AccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.circuit.v1.GenesisAccountPermissions"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "AccountsResponse is the response type for the Query/Accounts RPC method."
    },
    "cosmos.circuit.v1.DisabledListResponse": {
      "type": "object",
      "properties": {
        "disabledList": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "DisabledListResponse is the response type for the Query/DisabledList RPC method."
    },
    "cosmos.circuit.v1.GenesisAccountPermissions": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "permissions": {
          "$ref": "#/definitions/cosmos.circuit.v1.Permissions"
        }
      },
      "title": "GenesisAccountPermissions is the account permissions for the circuit breaker in genesis"
    },
    "cosmos.circuit.v1.Permissions": {
      "type": "object",
      "properties": {
        "level": {
          "$ref": "#/definitions/cosmos.circuit.v1.Permissions.Level",
          "description": "level is the level of permissions granted to this account."
        },
        "limitTypeUrls": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "limit_type_urls is used with LEVEL_SOME_MSGS to limit the lists of Msg type\nURLs that the account can trip. It is an error to use limit_type_urls with\na level other than LEVEL_SOME_MSGS."
        }
      },
      "description": "Permissions are the permissions that an account has to trip\nor reset the circuit breaker."
    },
    "cosmos.circuit.v1.Permissions.Level": {
      "type": "string",
      "enum": [
        "LEVEL_NONE_UNSPECIFIED",
        "LEVEL_SOME_MSGS",
        "LEVEL_ALL_MSGS",
        "LEVEL_SUPER_ADMIN"
      ],
      "default": "LEVEL_NONE_UNSPECIFIED",
      "description": "Level is the permission level.\n\n - LEVEL_NONE_UNSPECIFIED: LEVEL_NONE_UNSPECIFIED indicates that the account will have no circuit\nbreaker permissions.\n - LEVEL_SOME_MSGS: LEVEL_SOME_MSGS indicates that the account will have permission to\ntrip or reset the circuit breaker for some Msg type URLs. If this level\nis chosen, a non-empty list of Msg type URLs must be provided in\nlimit_type_urls.\n - LEVEL_ALL_MSGS: LEVEL_ALL_MSGS indicates that the account can trip or reset the circuit\nbreaker for Msg's of all type URLs.\n - LEVEL_SUPER_ADMIN: LEVEL_SUPER_ADMIN indicates that the account can take all circuit breaker\nactions and can grant permissions to other accounts."
    },
    "cosmos.consensus.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cometbft.types.v2.ConsensusParams",
          "description": "params are the tendermint consensus params stored in the consensus module.\nPlease note that `params.version` is not populated in this response, it is\ntracked separately in the x/upgrade module."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/consensus parameters."
    },
    "cosmos.counter.v1.QueryGetCountResponse": {
      "type": "object",
      "properties": {
        "totalCount": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "QueryGetCountResponse defines the response type for querying x/mock count."
    },
    "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
      "type": "object",
      "properties": {
        "extraBitsStored": {
          "type": "integer",
          "format": "int64"
        },
        "elems": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
    },
    "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
      "type": "object",
      "properties": {
        "validatorAddress": {
          "type": "string"
        },
        "reward": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          }
        }
      },
      "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
    },
    "cosmos.distribution.v1beta1.Params": {
      "type": "object",
      "properties": {
        "communityTax": {
          "type": "string"
        },
        "baseProposerReward": {
          "type": "string",
          "description": "Deprecated: The base_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
        },
        "bonusProposerReward": {
          "type": "string",
          "description": "Deprecated: The bonus_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
        },
        "withdrawAddrEnabled": {
          "type": "boolean"
        }
      },
      "description": "Params defines the set of params for the distribution module."
    },
    "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          },
          "description": "pool defines community pool's coins."
        }
      },
      "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          },
          "description": "rewards defines the rewards accrued by a delegation."
        }
      },
      "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.distribution.v1beta1.DelegationDelegatorReward"
          },
          "description": "rewards defines all the rewards accrued by a delegator."
        },
        "total": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          },
          "description": "total defines the sum of all the rewards."
        }
      },
      "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "validators defines the validators a delegator is delegating for."
        }
      },
      "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
      "type": "object",
      "properties": {
        "withdrawAddress": {
          "type": "string",
          "description": "withdraw_address defines the delegator address to query for."
        }
      },
      "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method."
    },
    "cosmos.distribution.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.distribution.v1beta1.Params",
          "description": "params defines the parameters of the module."
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
      "type": "object",
      "properties": {
        "commission": {
          "$ref": "#/definitions/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
          "description": "commission defines the commission the validator received."
        }
      },
      "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method"
    },
    "cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse": {
      "type": "object",
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": "operator_address defines the validator operator address."
        },
        "selfBondRewards": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          },
          "description": "self_bond_rewards defines the self delegations rewards."
        },
        "commission": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          },
          "description": "commission defines the commission the validator received."
        }
      },
      "description": "QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "$ref": "#/definitions/cosmos.distribution.v1beta1.ValidatorOutstandingRewards"
        }
      },
      "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
      "type": "object",
      "properties": {
        "slashes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.distribution.v1beta1.ValidatorSlashEvent"
          },
          "description": "slashes defines the slashes the validator received."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method."
    },
    "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
      "type": "object",
      "properties": {
        "commission": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          }
        }
      },
      "description": "ValidatorAccumulatedCommission represents accumulated commission\nfor a validator kept as a running counter, can be withdrawn at any time."
    },
    "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.DecCoin"
          }
        }
      },
      "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
    },
    "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
      "type": "object",
      "properties": {
        "validatorPeriod": {
          "type": "string",
          "format": "uint64"
        },
        "fraction": {
          "type": "string"
        }
      },
      "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
    },
    "cosmos.epochs.v1beta1.EpochInfo": {
      "type": "object",
      "properties": {
        "identifier": {
          "type": "string",
          "description": "identifier is a unique reference to this particular timer."
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "description": "start_time is the time at which the timer first ever ticks.\nIf start_time is in the future, the epoch will not begin until the start\ntime."
        },
        "duration": {
          "type": "string",
          "description": "duration is the time in between epoch ticks.\nIn order for intended behavior to be met, duration should\nbe greater than the chains expected block time.\nDuration must be non-zero."
        },
        "currentEpoch": {
          "type": "string",
          "format": "int64",
          "description": "current_epoch is the current epoch number, or in other words,\nhow many times has the timer 'ticked'.\nThe first tick (current_epoch=1) is defined as\nthe first block whose blocktime is greater than the EpochInfo start_time."
        },
        "currentEpochStartTime": {
          "type": "string",
          "format": "date-time",
          "description": "current_epoch_start_time describes the start time of the current timer\ninterval. The interval is (current_epoch_start_time,\ncurrent_epoch_start_time + duration] When the timer ticks, this is set to\ncurrent_epoch_start_time = last_epoch_start_time + duration only one timer\ntick for a given identifier can occur per block.\n\nNOTE! The current_epoch_start_time may diverge significantly from the\nwall-clock time the epoch began at. Wall-clock time of epoch start may be\n>> current_epoch_start_time. Suppose current_epoch_start_time = 10,\nduration = 5. Suppose the chain goes offline at t=14, and comes back online\nat t=30, and produces blocks at every successive time. (t=31, 32, etc.)\n* The t=30 block will start the epoch for (10, 15]\n* The t=31 block will start the epoch for (15, 20]\n* The t=32 block will start the epoch for (20, 25]\n* The t=33 block will start the epoch for (25, 30]\n* The t=34 block will start the epoch for (30, 35]\n* The **t=36** block will start the epoch for (35, 40]"
        },
        "epochCountingStarted": {
          "type": "boolean",
          "description": "epoch_counting_started is a boolean, that indicates whether this\nepoch timer has began yet."
        },
        "currentEpochStartHeight": {
          "type": "string",
          "format": "int64",
          "title": "current_epoch_start_height is the block height at which the current epoch\nstarted. (The block height at which the timer last ticked)"
        }
      },
      "description": "EpochInfo is a struct that describes the data going into\na timer defined by the x/epochs module."
    },
    "cosmos.epochs.v1beta1.QueryCurrentEpochResponse": {
      "type": "object",
      "properties": {
        "currentEpoch": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "QueryCurrentEpochResponse defines the gRPC response structure for\nquerying an epoch by its identifier."
    },
    "cosmos.epochs.v1beta1.QueryEpochInfosResponse": {
      "type": "object",
      "properties": {
        "epochs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.epochs.v1beta1.EpochInfo"
          }
        }
      },
      "description": "QueryEpochInfosRequest defines the gRPC response structure for\nquerying all epoch info."
    },
    "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "description": "evidence returns all evidences."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
    },
    "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "evidence returns the requested evidence."
        }
      },
      "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
    },
    "cosmos.feegrant.v1beta1.Grant": {
      "type": "object",
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        },
        "allowance": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "allowance can be any of basic, periodic, allowed fee allowance."
        }
      },
      "title": "Grant is stored in the KVStore to record a grant with full context"
    },
    "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
      "type": "object",
      "properties": {
        "allowance": {
          "$ref": "#/definitions/cosmos.feegrant.v1beta1.Grant",
          "description": "allowance is a allowance granted for grantee by granter."
        }
      },
      "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
    },
    "cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse": {
      "type": "object",
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.feegrant.v1beta1.Grant"
          },
          "description": "allowances that have been issued by the granter."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method."
    },
    "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
      "type": "object",
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.feegrant.v1beta1.Grant"
          },
          "description": "allowances are allowance's granted for grantee by granter."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an pagination for the response."
        }
      },
      "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
    },
    "cosmos.gov.v1.Deposit": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "amount to be deposited by depositor."
        }
      },
      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
    },
    "cosmos.gov.v1.DepositParams": {
      "type": "object",
      "properties": {
        "minDeposit": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "maxDepositPeriod": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
        }
      },
      "description": "DepositParams defines the params for deposits on governance proposals."
    },
    "cosmos.gov.v1.Params": {
      "type": "object",
      "properties": {
        "minDeposit": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "maxDepositPeriod": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
        },
        "votingPeriod": {
          "type": "string",
          "description": "Duration of the voting period."
        },
        "quorum": {
          "type": "string",
          "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
        },
        "threshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "vetoThreshold": {
          "type": "string",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
        },
        "minInitialDepositRatio": {
          "type": "string",
          "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
        },
        "proposalCancelRatio": {
          "type": "string",
          "description": "The cancel ratio which will not be returned back to the depositors when a proposal is cancelled."
        },
        "proposalCancelDest": {
          "type": "string",
          "description": "The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.\nIf empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned."
        },
        "expeditedVotingPeriod": {
          "type": "string",
          "description": "Duration of the voting period of an expedited proposal."
        },
        "expeditedThreshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.67."
        },
        "expeditedMinDeposit": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "Minimum expedited deposit for a proposal to enter voting period."
        },
        "burnVoteQuorum": {
          "type": "boolean",
          "title": "burn deposits if a proposal does not meet quorum"
        },
        "burnProposalDepositPrevote": {
          "type": "boolean",
          "title": "burn deposits if the proposal does not enter voting period"
        },
        "burnVoteVeto": {
          "type": "boolean",
          "title": "burn deposits if quorum with vote type no_veto is met"
        },
        "minDepositRatio": {
          "type": "string",
          "description": "The ratio representing the proportion of the deposit value minimum that must be met when making a deposit.\nDefault value: 0.01. Meaning that for a chain with a min_deposit of 100stake, a deposit of 1stake would be\nrequired."
        }
      },
      "description": "Params defines the parameters for the x/gov module."
    },
    "cosmos.gov.v1.Proposal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uint64",
          "description": "id defines the unique id of the proposal."
        },
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "description": "messages are the arbitrary messages to be executed if the proposal passes."
        },
        "status": {
          "$ref": "#/definitions/cosmos.gov.v1.ProposalStatus",
          "description": "status defines the proposal status."
        },
        "finalTallyResult": {
          "$ref": "#/definitions/cosmos.gov.v1.TallyResult",
          "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
        },
        "submitTime": {
          "type": "string",
          "format": "date-time",
          "description": "submit_time is the time of proposal submission."
        },
        "depositEndTime": {
          "type": "string",
          "format": "date-time",
          "description": "deposit_end_time is the end time for deposition."
        },
        "totalDeposit": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "total_deposit is the total deposit on the proposal."
        },
        "votingStartTime": {
          "type": "string",
          "format": "date-time",
          "description": "voting_start_time is the starting time to vote on a proposal."
        },
        "votingEndTime": {
          "type": "string",
          "format": "date-time",
          "description": "voting_end_time is the end time of voting on a proposal."
        },
        "metadata": {
          "type": "string",
          "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/gov#proposal-3"
        },
        "title": {
          "type": "string",
          "title": "title is the title of the proposal"
        },
        "summary": {
          "type": "string",
          "title": "summary is a short summary of the proposal"
        },
        "proposer": {
          "type": "string",
          "title": "proposer is the address of the proposal sumbitter"
        },
        "expedited": {
          "type": "boolean",
          "title": "expedited defines if the proposal is expedited"
        },
        "failedReason": {
          "type": "string",
          "title": "failed_reason defines the reason why the proposal failed"
        }
      },
      "description": "Proposal defines the core field members of a governance proposal."
    },
    "cosmos.gov.v1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
        "PROPOSAL_STATUS_VOTING_PERIOD",
        "PROPOSAL_STATUS_PASSED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_FAILED"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
    },
    "cosmos.gov.v1.QueryConstitutionResponse": {
      "type": "object",
      "properties": {
        "constitution": {
          "type": "string"
        }
      },
      "title": "QueryConstitutionResponse is the response type for the Query/Constitution RPC method"
    },
    "cosmos.gov.v1.QueryDepositResponse": {
      "type": "object",
      "properties": {
        "deposit": {
          "$ref": "#/definitions/cosmos.gov.v1.Deposit",
          "description": "deposit defines the requested deposit."
        }
      },
      "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
    },
    "cosmos.gov.v1.QueryDepositsResponse": {
      "type": "object",
      "properties": {
        "deposits": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1.Deposit"
          },
          "description": "deposits defines the requested deposits."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
    },
    "cosmos.gov.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "votingParams": {
          "$ref": "#/definitions/cosmos.gov.v1.VotingParams",
          "description": "Deprecated: Prefer to use `params` instead.\nvoting_params defines the parameters related to voting."
        },
        "depositParams": {
          "$ref": "#/definitions/cosmos.gov.v1.DepositParams",
          "description": "Deprecated: Prefer to use `params` instead.\ndeposit_params defines the parameters related to deposit."
        },
        "tallyParams": {
          "$ref": "#/definitions/cosmos.gov.v1.TallyParams",
          "description": "Deprecated: Prefer to use `params` instead.\ntally_params defines the parameters related to tally."
        },
        "params": {
          "$ref": "#/definitions/cosmos.gov.v1.Params",
          "description": "params defines all the paramaters of x/gov module."
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.gov.v1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "$ref": "#/definitions/cosmos.gov.v1.Proposal",
          "description": "proposal is the requested governance proposal."
        }
      },
      "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
    },
    "cosmos.gov.v1.QueryProposalsResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1.Proposal"
          },
          "description": "proposals defines all the requested governance proposals."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
    },
    "cosmos.gov.v1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "$ref": "#/definitions/cosmos.gov.v1.TallyResult",
          "description": "tally defines the requested tally."
        }
      },
      "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
    },
    "cosmos.gov.v1.QueryVoteResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "$ref": "#/definitions/cosmos.gov.v1.Vote",
          "description": "vote defines the queried vote."
        }
      },
      "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
    },
    "cosmos.gov.v1.QueryVotesResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1.Vote"
          },
          "description": "votes defines the queried votes."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
    },
    "cosmos.gov.v1.TallyParams": {
      "type": "object",
      "properties": {
        "quorum": {
          "type": "string",
          "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
        },
        "threshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "vetoThreshold": {
          "type": "string",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
        }
      },
      "description": "TallyParams defines the params for tallying votes on governance proposals."
    },
    "cosmos.gov.v1.TallyResult": {
      "type": "object",
      "properties": {
        "yesCount": {
          "type": "string",
          "description": "yes_count is the number of yes votes on a proposal."
        },
        "abstainCount": {
          "type": "string",
          "description": "abstain_count is the number of abstain votes on a proposal."
        },
        "noCount": {
          "type": "string",
          "description": "no_count is the number of no votes on a proposal."
        },
        "noWithVetoCount": {
          "type": "string",
          "description": "no_with_veto_count is the number of no with veto votes on a proposal."
        }
      },
      "description": "TallyResult defines a standard tally for a governance proposal."
    },
    "cosmos.gov.v1.Vote": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address of the proposal."
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1.WeightedVoteOption"
          },
          "description": "options is the weighted vote options."
        },
        "metadata": {
          "type": "string",
          "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5"
        }
      },
      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
    },
    "cosmos.gov.v1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.gov.v1.VotingParams": {
      "type": "object",
      "properties": {
        "votingPeriod": {
          "type": "string",
          "description": "Duration of the voting period."
        }
      },
      "description": "VotingParams defines the params for voting on governance proposals."
    },
    "cosmos.gov.v1.WeightedVoteOption": {
      "type": "object",
      "properties": {
        "option": {
          "$ref": "#/definitions/cosmos.gov.v1.VoteOption",
          "description": "option defines the valid vote options, it must not contain duplicate vote options."
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "description": "WeightedVoteOption defines a unit of vote for vote split."
    },
    "cosmos.gov.v1beta1.Deposit": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "amount to be deposited by depositor."
        }
      },
      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
    },
    "cosmos.gov.v1beta1.DepositParams": {
      "type": "object",
      "properties": {
        "minDeposit": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "maxDepositPeriod": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
        }
      },
      "description": "DepositParams defines the params for deposits on governance proposals."
    },
    "cosmos.gov.v1beta1.Proposal": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "content": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "content is the proposal's content."
        },
        "status": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.ProposalStatus",
          "description": "status defines the proposal status."
        },
        "finalTallyResult": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.TallyResult",
          "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
        },
        "submitTime": {
          "type": "string",
          "format": "date-time",
          "description": "submit_time is the time of proposal submission."
        },
        "depositEndTime": {
          "type": "string",
          "format": "date-time",
          "description": "deposit_end_time is the end time for deposition."
        },
        "totalDeposit": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "total_deposit is the total deposit on the proposal."
        },
        "votingStartTime": {
          "type": "string",
          "format": "date-time",
          "description": "voting_start_time is the starting time to vote on a proposal."
        },
        "votingEndTime": {
          "type": "string",
          "format": "date-time",
          "description": "voting_end_time is the end time of voting on a proposal."
        }
      },
      "description": "Proposal defines the core field members of a governance proposal."
    },
    "cosmos.gov.v1beta1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
        "PROPOSAL_STATUS_VOTING_PERIOD",
        "PROPOSAL_STATUS_PASSED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_FAILED"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
    },
    "cosmos.gov.v1beta1.QueryDepositResponse": {
      "type": "object",
      "properties": {
        "deposit": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.Deposit",
          "description": "deposit defines the requested deposit."
        }
      },
      "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
    },
    "cosmos.gov.v1beta1.QueryDepositsResponse": {
      "type": "object",
      "properties": {
        "deposits": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1beta1.Deposit"
          },
          "description": "deposits defines the requested deposits."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
    },
    "cosmos.gov.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "votingParams": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.VotingParams",
          "description": "voting_params defines the parameters related to voting."
        },
        "depositParams": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.DepositParams",
          "description": "deposit_params defines the parameters related to deposit."
        },
        "tallyParams": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.TallyParams",
          "description": "tally_params defines the parameters related to tally."
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.Proposal"
        }
      },
      "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalsResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1beta1.Proposal"
          },
          "description": "proposals defines all the requested governance proposals."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
    },
    "cosmos.gov.v1beta1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.TallyResult",
          "description": "tally defines the requested tally."
        }
      },
      "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
    },
    "cosmos.gov.v1beta1.QueryVoteResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.Vote",
          "description": "vote defines the queried vote."
        }
      },
      "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
    },
    "cosmos.gov.v1beta1.QueryVotesResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1beta1.Vote"
          },
          "description": "votes defines the queried votes."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
    },
    "cosmos.gov.v1beta1.TallyParams": {
      "type": "object",
      "properties": {
        "quorum": {
          "type": "string",
          "format": "byte",
          "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
        },
        "threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "vetoThreshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
        }
      },
      "description": "TallyParams defines the params for tallying votes on governance proposals."
    },
    "cosmos.gov.v1beta1.TallyResult": {
      "type": "object",
      "properties": {
        "yes": {
          "type": "string",
          "description": "yes is the number of yes votes on a proposal."
        },
        "abstain": {
          "type": "string",
          "description": "abstain is the number of abstain votes on a proposal."
        },
        "no": {
          "type": "string",
          "description": "no is the number of no votes on a proposal."
        },
        "noWithVeto": {
          "type": "string",
          "description": "no_with_veto is the number of no with veto votes on a proposal."
        }
      },
      "description": "TallyResult defines a standard tally for a governance proposal."
    },
    "cosmos.gov.v1beta1.Vote": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address of the proposal."
        },
        "option": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.VoteOption",
          "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED."
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
          },
          "description": "options is the weighted vote options."
        }
      },
      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
    },
    "cosmos.gov.v1beta1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.gov.v1beta1.VotingParams": {
      "type": "object",
      "properties": {
        "votingPeriod": {
          "type": "string",
          "description": "Duration of the voting period."
        }
      },
      "description": "VotingParams defines the params for voting on governance proposals."
    },
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      "type": "object",
      "properties": {
        "option": {
          "$ref": "#/definitions/cosmos.gov.v1beta1.VoteOption",
          "description": "option defines the valid vote options, it must not contain duplicate vote options."
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "description": "WeightedVoteOption defines a unit of vote for vote split."
    },
    "cosmos.group.v1.GroupInfo": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uint64",
          "description": "id is the unique ID of the group."
        },
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group's admin."
        },
        "metadata": {
          "type": "string",
          "title": "metadata is any arbitrary metadata to attached to the group.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/group#group-1"
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "title": "version is used to track changes to a group's membership structure that\nwould break existing proposals. Whenever any members weight is changed,\nor any member is added or removed this version is incremented and will\ncause proposals based on older versions of this group to fail"
        },
        "totalWeight": {
          "type": "string",
          "description": "total_weight is the sum of the group members' weights."
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "created_at is a timestamp specifying when a group was created."
        }
      },
      "description": "GroupInfo represents the high-level on-chain information for a group."
    },
    "cosmos.group.v1.GroupMember": {
      "type": "object",
      "properties": {
        "groupId": {
          "type": "string",
          "format": "uint64",
          "description": "group_id is the unique ID of the group."
        },
        "member": {
          "$ref": "#/definitions/cosmos.group.v1.Member",
          "description": "member is the member data."
        }
      },
      "description": "GroupMember represents the relationship between a group and a member."
    },
    "cosmos.group.v1.GroupPolicyInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the account address of group policy."
        },
        "groupId": {
          "type": "string",
          "format": "uint64",
          "description": "group_id is the unique ID of the group."
        },
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "metadata": {
          "type": "string",
          "title": "metadata is any arbitrary metadata attached to the group policy.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/group#decision-policy-1"
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "version is used to track changes to a group's GroupPolicyInfo structure that\nwould create a different result on a running proposal."
        },
        "decisionPolicy": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "decision_policy specifies the group policy's decision policy."
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "created_at is a timestamp specifying when a group policy was created."
        }
      },
      "description": "GroupPolicyInfo represents the high-level on-chain information for a group policy."
    },
    "cosmos.group.v1.Member": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        },
        "addedAt": {
          "type": "string",
          "format": "date-time",
          "description": "added_at is a timestamp specifying when a member was added."
        }
      },
      "description": "Member represents a group member with an account address,\nnon-zero weight, metadata and added_at timestamp."
    },
    "cosmos.group.v1.Proposal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uint64",
          "description": "id is the unique id of the proposal."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "metadata": {
          "type": "string",
          "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/group#proposal-4"
        },
        "proposers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "proposers are the account addresses of the proposers."
        },
        "submitTime": {
          "type": "string",
          "format": "date-time",
          "description": "submit_time is a timestamp specifying when a proposal was submitted."
        },
        "groupVersion": {
          "type": "string",
          "format": "uint64",
          "description": "group_version tracks the version of the group at proposal submission.\nThis field is here for informational purposes only."
        },
        "groupPolicyVersion": {
          "type": "string",
          "format": "uint64",
          "description": "group_policy_version tracks the version of the group policy at proposal submission.\nWhen a decision policy is changed, existing proposals from previous policy\nversions will become invalid with the `ABORTED` status.\nThis field is here for informational purposes only."
        },
        "status": {
          "$ref": "#/definitions/cosmos.group.v1.ProposalStatus",
          "description": "status represents the high level position in the life cycle of the proposal. Initial value is Submitted."
        },
        "finalTallyResult": {
          "$ref": "#/definitions/cosmos.group.v1.TallyResult",
          "description": "final_tally_result contains the sums of all weighted votes for this\nproposal for each vote option. It is empty at submission, and only\npopulated after tallying, at voting period end or at proposal execution,\nwhichever happens first."
        },
        "votingPeriodEnd": {
          "type": "string",
          "format": "date-time",
          "description": "voting_period_end is the timestamp before which voting must be done.\nUnless a successful MsgExec is called before (to execute a proposal whose\ntally is successful before the voting period ends), tallying will be done\nat this point, and the `final_tally_result`and `status` fields will be\naccordingly updated."
        },
        "executorResult": {
          "$ref": "#/definitions/cosmos.group.v1.ProposalExecutorResult",
          "description": "executor_result is the final result of the proposal execution. Initial value is NotRun."
        },
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes."
        },
        "title": {
          "type": "string",
          "title": "title is the title of the proposal"
        },
        "summary": {
          "type": "string",
          "title": "summary is a short summary of the proposal"
        }
      },
      "description": "Proposal defines a group proposal. Any member of a group can submit a proposal\nfor a group policy to decide upon.\nA proposal consists of a set of `sdk.Msg`s that will be executed if the proposal\npasses as well as some optional metadata associated with the proposal."
    },
    "cosmos.group.v1.ProposalExecutorResult": {
      "type": "string",
      "enum": [
        "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED",
        "PROPOSAL_EXECUTOR_RESULT_NOT_RUN",
        "PROPOSAL_EXECUTOR_RESULT_SUCCESS",
        "PROPOSAL_EXECUTOR_RESULT_FAILURE"
      ],
      "default": "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED",
      "description": "ProposalExecutorResult defines types of proposal executor results.\n\n - PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED: An empty value is not allowed.\n - PROPOSAL_EXECUTOR_RESULT_NOT_RUN: We have not yet run the executor.\n - PROPOSAL_EXECUTOR_RESULT_SUCCESS: The executor was successful and proposed action updated state.\n - PROPOSAL_EXECUTOR_RESULT_FAILURE: The executor returned an error and proposed action didn't update state."
    },
    "cosmos.group.v1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_SUBMITTED",
        "PROPOSAL_STATUS_ACCEPTED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_ABORTED",
        "PROPOSAL_STATUS_WITHDRAWN"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus defines proposal statuses.\n\n - PROPOSAL_STATUS_UNSPECIFIED: An empty value is invalid and not allowed.\n - PROPOSAL_STATUS_SUBMITTED: Initial status of a proposal when submitted.\n - PROPOSAL_STATUS_ACCEPTED: Final status of a proposal when the final tally is done and the outcome\npasses the group policy's decision policy.\n - PROPOSAL_STATUS_REJECTED: Final status of a proposal when the final tally is done and the outcome\nis rejected by the group policy's decision policy.\n - PROPOSAL_STATUS_ABORTED: Final status of a proposal when the group policy is modified before the\nfinal tally.\n - PROPOSAL_STATUS_WITHDRAWN: A proposal can be withdrawn before the voting start time by the owner.\nWhen this happens the final status is Withdrawn."
    },
    "cosmos.group.v1.QueryGroupInfoResponse": {
      "type": "object",
      "properties": {
        "info": {
          "$ref": "#/definitions/cosmos.group.v1.GroupInfo",
          "description": "info is the GroupInfo of the group."
        }
      },
      "description": "QueryGroupInfoResponse is the Query/GroupInfo response type."
    },
    "cosmos.group.v1.QueryGroupMembersResponse": {
      "type": "object",
      "properties": {
        "members": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.GroupMember"
          },
          "description": "members are the members of the group with given group_id."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryGroupMembersResponse is the Query/GroupMembersResponse response type."
    },
    "cosmos.group.v1.QueryGroupPoliciesByAdminResponse": {
      "type": "object",
      "properties": {
        "groupPolicies": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.GroupPolicyInfo"
          },
          "description": "group_policies are the group policies info with provided admin."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type."
    },
    "cosmos.group.v1.QueryGroupPoliciesByGroupResponse": {
      "type": "object",
      "properties": {
        "groupPolicies": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.GroupPolicyInfo"
          },
          "description": "group_policies are the group policies info associated with the provided group."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type."
    },
    "cosmos.group.v1.QueryGroupPolicyInfoResponse": {
      "type": "object",
      "properties": {
        "info": {
          "$ref": "#/definitions/cosmos.group.v1.GroupPolicyInfo",
          "description": "info is the GroupPolicyInfo of the group policy."
        }
      },
      "description": "QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type."
    },
    "cosmos.group.v1.QueryGroupsByAdminResponse": {
      "type": "object",
      "properties": {
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.GroupInfo"
          },
          "description": "groups are the groups info with the provided admin."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type."
    },
    "cosmos.group.v1.QueryGroupsByMemberResponse": {
      "type": "object",
      "properties": {
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.GroupInfo"
          },
          "description": "groups are the groups info with the provided group member."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryGroupsByMemberResponse is the Query/GroupsByMember response type."
    },
    "cosmos.group.v1.QueryGroupsResponse": {
      "type": "object",
      "properties": {
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.GroupInfo"
          },
          "description": "`groups` is all the groups present in state."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryGroupsResponse is the Query/Groups response type."
    },
    "cosmos.group.v1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "$ref": "#/definitions/cosmos.group.v1.Proposal",
          "description": "proposal is the proposal info."
        }
      },
      "description": "QueryProposalResponse is the Query/Proposal response type."
    },
    "cosmos.group.v1.QueryProposalsByGroupPolicyResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.Proposal"
          },
          "description": "proposals are the proposals with given group policy."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type."
    },
    "cosmos.group.v1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "$ref": "#/definitions/cosmos.group.v1.TallyResult",
          "description": "tally defines the requested tally."
        }
      },
      "description": "QueryTallyResultResponse is the Query/TallyResult response type."
    },
    "cosmos.group.v1.QueryVoteByProposalVoterResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "$ref": "#/definitions/cosmos.group.v1.Vote",
          "description": "vote is the vote with given proposal_id and voter."
        }
      },
      "description": "QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type."
    },
    "cosmos.group.v1.QueryVotesByProposalResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.Vote"
          },
          "description": "votes are the list of votes for given proposal_id."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryVotesByProposalResponse is the Query/VotesByProposal response type."
    },
    "cosmos.group.v1.QueryVotesByVoterResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.group.v1.Vote"
          },
          "description": "votes are the list of votes by given voter."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryVotesByVoterResponse is the Query/VotesByVoter response type."
    },
    "cosmos.group.v1.TallyResult": {
      "type": "object",
      "properties": {
        "yesCount": {
          "type": "string",
          "description": "yes_count is the weighted sum of yes votes."
        },
        "abstainCount": {
          "type": "string",
          "description": "abstain_count is the weighted sum of abstainers."
        },
        "noCount": {
          "type": "string",
          "description": "no_count is the weighted sum of no votes."
        },
        "noWithVetoCount": {
          "type": "string",
          "description": "no_with_veto_count is the weighted sum of veto."
        }
      },
      "description": "TallyResult represents the sum of weighted votes for each vote option."
    },
    "cosmos.group.v1.Vote": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "uint64",
          "description": "proposal is the unique ID of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the account address of the voter."
        },
        "option": {
          "$ref": "#/definitions/cosmos.group.v1.VoteOption",
          "description": "option is the voter's choice on the proposal."
        },
        "metadata": {
          "type": "string",
          "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/group#vote-2"
        },
        "submitTime": {
          "type": "string",
          "format": "date-time",
          "description": "submit_time is the timestamp when the vote was submitted."
        }
      },
      "title": "Vote represents a vote for a proposal.string metadata"
    },
    "cosmos.group.v1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will\nreturn an error.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.mint.v1beta1.Params": {
      "type": "object",
      "properties": {
        "mintDenom": {
          "type": "string",
          "title": "type of coin to mint"
        },
        "inflationRateChange": {
          "type": "string",
          "title": "maximum annual change in inflation rate"
        },
        "inflationMax": {
          "type": "string",
          "title": "maximum inflation rate"
        },
        "inflationMin": {
          "type": "string",
          "title": "minimum inflation rate"
        },
        "goalBonded": {
          "type": "string",
          "title": "goal of percent bonded atoms"
        },
        "blocksPerYear": {
          "type": "string",
          "format": "uint64",
          "title": "expected blocks per year"
        }
      },
      "description": "Params defines the parameters for the x/mint module."
    },
    "cosmos.mint.v1beta1.QueryAnnualProvisionsResponse": {
      "type": "object",
      "properties": {
        "annualProvisions": {
          "type": "string",
          "format": "byte",
          "description": "annual_provisions is the current minting annual provisions value."
        }
      },
      "description": "QueryAnnualProvisionsResponse is the response type for the\nQuery/AnnualProvisions RPC method."
    },
    "cosmos.mint.v1beta1.QueryInflationResponse": {
      "type": "object",
      "properties": {
        "inflation": {
          "type": "string",
          "format": "byte",
          "description": "inflation is the current minting inflation value."
        }
      },
      "description": "QueryInflationResponse is the response type for the Query/Inflation RPC\nmethod."
    },
    "cosmos.mint.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.mint.v1beta1.Params",
          "description": "params defines the parameters of the module."
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.nft.v1beta1.Class": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "id defines the unique identifier of the NFT classification, similar to the contract address of ERC721"
        },
        "name": {
          "type": "string",
          "title": "name defines the human-readable name of the NFT classification. Optional"
        },
        "symbol": {
          "type": "string",
          "title": "symbol is an abbreviated name for nft classification. Optional"
        },
        "description": {
          "type": "string",
          "title": "description is a brief description of nft classification. Optional"
        },
        "uri": {
          "type": "string",
          "title": "uri for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional"
        },
        "uriHash": {
          "type": "string",
          "title": "uri_hash is a hash of the document pointed by uri. Optional"
        },
        "data": {
          "$ref": "#/definitions/google.protobuf.Any",
          "title": "data is the app specific metadata of the NFT class. Optional"
        }
      },
      "description": "Class defines the class of the nft type."
    },
    "cosmos.nft.v1beta1.NFT": {
      "type": "object",
      "properties": {
        "classId": {
          "type": "string",
          "title": "class_id associated with the NFT, similar to the contract address of ERC721"
        },
        "id": {
          "type": "string",
          "title": "id is a unique identifier of the NFT"
        },
        "uri": {
          "type": "string",
          "title": "uri for the NFT metadata stored off chain"
        },
        "uriHash": {
          "type": "string",
          "title": "uri_hash is a hash of the document pointed by uri"
        },
        "data": {
          "$ref": "#/definitions/google.protobuf.Any",
          "title": "data is an app specific data of the NFT. Optional"
        }
      },
      "description": "NFT defines the NFT."
    },
    "cosmos.nft.v1beta1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "string",
          "format": "uint64",
          "title": "amount is the number of all NFTs of a given class owned by the owner"
        }
      },
      "title": "QueryBalanceResponse is the response type for the Query/Balance RPC method"
    },
    "cosmos.nft.v1beta1.QueryClassResponse": {
      "type": "object",
      "properties": {
        "class": {
          "$ref": "#/definitions/cosmos.nft.v1beta1.Class",
          "description": "class defines the class of the nft type."
        }
      },
      "title": "QueryClassResponse is the response type for the Query/Class RPC method"
    },
    "cosmos.nft.v1beta1.QueryClassesResponse": {
      "type": "object",
      "properties": {
        "classes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.nft.v1beta1.Class"
          },
          "description": "class defines the class of the nft type."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "title": "QueryClassesResponse is the response type for the Query/Classes RPC method"
    },
    "cosmos.nft.v1beta1.QueryNFTResponse": {
      "type": "object",
      "properties": {
        "nft": {
          "$ref": "#/definitions/cosmos.nft.v1beta1.NFT",
          "title": "owner is the owner address of the nft"
        }
      },
      "title": "QueryNFTResponse is the response type for the Query/NFT RPC method"
    },
    "cosmos.nft.v1beta1.QueryNFTsResponse": {
      "type": "object",
      "properties": {
        "nfts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.nft.v1beta1.NFT"
          },
          "title": "NFT defines the NFT"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "title": "QueryNFTsResponse is the response type for the Query/NFTs RPC methods"
    },
    "cosmos.nft.v1beta1.QueryOwnerResponse": {
      "type": "object",
      "properties": {
        "owner": {
          "type": "string",
          "title": "owner is the owner address of the nft"
        }
      },
      "title": "QueryOwnerResponse is the response type for the Query/Owner RPC method"
    },
    "cosmos.nft.v1beta1.QuerySupplyResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "string",
          "format": "uint64",
          "title": "amount is the number of all NFTs from the given class"
        }
      },
      "title": "QuerySupplyResponse is the response type for the Query/Supply RPC method"
    },
    "cosmos.params.v1beta1.ParamChange": {
      "type": "object",
      "properties": {
        "subspace": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "description": "ParamChange defines an individual parameter change, for use in\nParameterChangeProposal."
    },
    "cosmos.params.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "param": {
          "$ref": "#/definitions/cosmos.params.v1beta1.ParamChange",
          "description": "param defines the queried parameter."
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "cosmos.params.v1beta1.QuerySubspacesResponse": {
      "type": "object",
      "properties": {
        "subspaces": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.params.v1beta1.Subspace"
          }
        }
      },
      "description": "QuerySubspacesResponse defines the response types for querying for all\nregistered subspaces and all keys for a subspace."
    },
    "cosmos.params.v1beta1.Subspace": {
      "type": "object",
      "properties": {
        "subspace": {
          "type": "string"
        },
        "keys": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Subspace defines a parameter subspace name and all the keys that exist for\nthe subspace."
    },
    "cosmos.protocolpool.v1.ContinuousFund": {
      "type": "object",
      "properties": {
        "recipient": {
          "type": "string",
          "description": "Recipient is the address string of the account receiving funds."
        },
        "percentage": {
          "type": "string",
          "description": "Percentage is the percentage of funds to be allocated from Community pool."
        },
        "expiry": {
          "type": "string",
          "format": "date-time",
          "description": "Optional, if expiry is set, removes the state object when expired."
        }
      },
      "description": "ContinuousFund defines the fields of continuous fund proposal."
    },
    "cosmos.protocolpool.v1.Params": {
      "type": "object",
      "properties": {
        "enabledDistributionDenoms": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "EnabledDistributionDenoms lists the denoms that are allowed to be distributed.\nThis is to avoid spending time distributing undesired tokens to continuous funds and budgets."
        },
        "distributionFrequency": {
          "type": "string",
          "format": "uint64",
          "description": "DistributionFrequency is the frequency (in terms of blocks) that funds are distributed out from the\nx/protocolpool module."
        }
      },
      "description": "Params defines the parameters for the protocolpool module."
    },
    "cosmos.protocolpool.v1.QueryCommunityPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "pool defines community pool's coins."
        }
      },
      "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method."
    },
    "cosmos.protocolpool.v1.QueryContinuousFundResponse": {
      "type": "object",
      "properties": {
        "continuousFund": {
          "$ref": "#/definitions/cosmos.protocolpool.v1.ContinuousFund",
          "description": "ContinuousFunds is the given continuous fund returned in the query."
        }
      },
      "description": "QueryUnclaimedBudgetResponse is the response type for the Query/ContinuousFund\nRPC method."
    },
    "cosmos.protocolpool.v1.QueryContinuousFundsResponse": {
      "type": "object",
      "properties": {
        "continuousFunds": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.protocolpool.v1.ContinuousFund"
          },
          "description": "ContinuousFunds defines all continuous funds in state."
        }
      },
      "description": "QueryUnclaimedBudgetResponse is the response type for the Query/ContinuousFunds\nRPC method."
    },
    "cosmos.protocolpool.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.protocolpool.v1.Params"
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.slashing.v1beta1.Params": {
      "type": "object",
      "properties": {
        "signedBlocksWindow": {
          "type": "string",
          "format": "int64"
        },
        "minSignedPerWindow": {
          "type": "string",
          "format": "byte"
        },
        "downtimeJailDuration": {
          "type": "string"
        },
        "slashFractionDoubleSign": {
          "type": "string",
          "format": "byte"
        },
        "slashFractionDowntime": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Params represents the parameters used for by the slashing module."
    },
    "cosmos.slashing.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.slashing.v1beta1.Params"
        }
      },
      "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
      "type": "object",
      "properties": {
        "valSigningInfo": {
          "$ref": "#/definitions/cosmos.slashing.v1beta1.ValidatorSigningInfo",
          "title": "val_signing_info is the signing info of requested val cons address"
        }
      },
      "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
      "type": "object",
      "properties": {
        "info": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.slashing.v1beta1.ValidatorSigningInfo"
          },
          "title": "info is the signing info of all validators"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse"
        }
      },
      "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod"
    },
    "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "startHeight": {
          "type": "string",
          "format": "int64",
          "title": "Height at which validator was first a candidate OR was un-jailed"
        },
        "indexOffset": {
          "type": "string",
          "format": "int64",
          "description": "Index which is incremented every time a validator is bonded in a block and\n_may_ have signed a pre-commit or not. This in conjunction with the\nsigned_blocks_window param determines the index in the missed block bitmap."
        },
        "jailedUntil": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp until which the validator is jailed due to liveness downtime."
        },
        "tombstoned": {
          "type": "boolean",
          "description": "Whether or not a validator has been tombstoned (killed out of validator\nset). It is set once the validator commits an equivocation or for any other\nconfigured misbehavior."
        },
        "missedBlocksCounter": {
          "type": "string",
          "format": "int64",
          "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary\nreads in the missed block bitmap."
        }
      },
      "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
    },
    "cosmos.staking.v1beta1.BondStatus": {
      "type": "string",
      "enum": [
        "BOND_STATUS_UNSPECIFIED",
        "BOND_STATUS_UNBONDED",
        "BOND_STATUS_UNBONDING",
        "BOND_STATUS_BONDED"
      ],
      "default": "BOND_STATUS_UNSPECIFIED",
      "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
    },
    "cosmos.staking.v1beta1.Commission": {
      "type": "object",
      "properties": {
        "commissionRates": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
          "description": "commission_rates defines the initial commission rates to be used for creating a validator."
        },
        "updateTime": {
          "type": "string",
          "format": "date-time",
          "description": "update_time is the last time the commission rate was changed."
        }
      },
      "description": "Commission defines commission parameters for a given validator."
    },
    "cosmos.staking.v1beta1.CommissionRates": {
      "type": "object",
      "properties": {
        "rate": {
          "type": "string",
          "description": "rate is the commission rate charged to delegators, as a fraction."
        },
        "maxRate": {
          "type": "string",
          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
        },
        "maxChangeRate": {
          "type": "string",
          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
        }
      },
      "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
    },
    "cosmos.staking.v1beta1.Delegation": {
      "type": "object",
      "properties": {
        "delegatorAddress": {
          "type": "string",
          "description": "delegator_address is the encoded address of the delegator."
        },
        "validatorAddress": {
          "type": "string",
          "description": "validator_address is the encoded address of the validator."
        },
        "shares": {
          "type": "string",
          "description": "shares define the delegation shares received."
        }
      },
      "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
    },
    "cosmos.staking.v1beta1.DelegationResponse": {
      "type": "object",
      "properties": {
        "delegation": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Delegation"
        },
        "balance": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
        }
      },
      "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
    },
    "cosmos.staking.v1beta1.Description": {
      "type": "object",
      "properties": {
        "moniker": {
          "type": "string",
          "description": "moniker defines a human-readable name for the validator."
        },
        "identity": {
          "type": "string",
          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
        },
        "website": {
          "type": "string",
          "description": "website defines an optional website link."
        },
        "securityContact": {
          "type": "string",
          "description": "security_contact defines an optional email for security contact."
        },
        "details": {
          "type": "string",
          "description": "details define other optional details."
        }
      },
      "description": "Description defines a validator description."
    },
    "cosmos.staking.v1beta1.HistoricalInfo": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/cometbft.types.v2.Header"
        },
        "valset": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.Validator"
          }
        }
      },
      "description": "HistoricalInfo contains header and validator information for a given block.\nIt is stored as part of staking module's state, which persists the `n` most\nrecent HistoricalInfo\n(`n` is set by the staking module's `historical_entries` parameter)."
    },
    "cosmos.staking.v1beta1.Params": {
      "type": "object",
      "properties": {
        "unbondingTime": {
          "type": "string",
          "description": "unbonding_time is the time duration of unbonding."
        },
        "maxValidators": {
          "type": "integer",
          "format": "int64",
          "description": "max_validators is the maximum number of validators."
        },
        "maxEntries": {
          "type": "integer",
          "format": "int64",
          "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."
        },
        "historicalEntries": {
          "type": "integer",
          "format": "int64",
          "description": "historical_entries is the number of historical entries to persist."
        },
        "bondDenom": {
          "type": "string",
          "description": "bond_denom defines the bondable coin denomination."
        },
        "minCommissionRate": {
          "type": "string",
          "title": "min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators"
        }
      },
      "description": "Params defines the parameters for the x/staking module."
    },
    "cosmos.staking.v1beta1.Pool": {
      "type": "object",
      "properties": {
        "notBondedTokens": {
          "type": "string"
        },
        "bondedTokens": {
          "type": "string"
        }
      },
      "description": "Pool is used for tracking bonded and not-bonded token supply of the bond\ndenomination."
    },
    "cosmos.staking.v1beta1.QueryDelegationResponse": {
      "type": "object",
      "properties": {
        "delegationResponse": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.DelegationResponse",
          "description": "delegation_responses defines the delegation info of a delegation."
        }
      },
      "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
      "type": "object",
      "properties": {
        "delegationResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.DelegationResponse"
          },
          "description": "delegation_responses defines all the delegations' info of a delegator."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
      "type": "object",
      "properties": {
        "unbondingResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.UnbondingDelegation"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Validator",
          "description": "validator defines the validator info."
        }
      },
      "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.Validator"
          },
          "description": "validators defines the validators' info of a delegator."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method."
    },
    "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
      "type": "object",
      "properties": {
        "hist": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.HistoricalInfo",
          "description": "hist defines the historical info at the given height."
        }
      },
      "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod."
    },
    "cosmos.staking.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Params",
          "description": "params holds all the parameters of this module."
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "cosmos.staking.v1beta1.QueryPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Pool",
          "description": "pool defines the pool info."
        }
      },
      "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
    },
    "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
      "type": "object",
      "properties": {
        "redelegationResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.RedelegationResponse"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod."
    },
    "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
      "type": "object",
      "properties": {
        "unbond": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.UnbondingDelegation",
          "description": "unbond defines the unbonding information of a delegation."
        }
      },
      "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method."
    },
    "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
      "type": "object",
      "properties": {
        "delegationResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.DelegationResponse"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method"
    },
    "cosmos.staking.v1beta1.QueryValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Validator",
          "description": "validator defines the validator info."
        }
      },
      "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
    },
    "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
      "type": "object",
      "properties": {
        "unbondingResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.UnbondingDelegation"
          }
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.Validator"
          },
          "description": "validators contains all the queried validators."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
    },
    "cosmos.staking.v1beta1.Redelegation": {
      "type": "object",
      "properties": {
        "delegatorAddress": {
          "type": "string",
          "description": "delegator_address is the bech32-encoded address of the delegator."
        },
        "validatorSrcAddress": {
          "type": "string",
          "description": "validator_src_address is the validator redelegation source operator address."
        },
        "validatorDstAddress": {
          "type": "string",
          "description": "validator_dst_address is the validator redelegation destination operator address."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.RedelegationEntry"
          },
          "description": "entries are the redelegation entries.\n\nredelegation entries"
        }
      },
      "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
    },
    "cosmos.staking.v1beta1.RedelegationEntry": {
      "type": "object",
      "properties": {
        "creationHeight": {
          "type": "string",
          "format": "int64",
          "description": "creation_height  defines the height which the redelegation took place."
        },
        "completionTime": {
          "type": "string",
          "format": "date-time",
          "description": "completion_time defines the unix time for redelegation completion."
        },
        "initialBalance": {
          "type": "string",
          "description": "initial_balance defines the initial balance when redelegation started."
        },
        "sharesDst": {
          "type": "string",
          "description": "shares_dst is the amount of destination-validator shares created by redelegation."
        },
        "unbondingId": {
          "type": "string",
          "format": "uint64",
          "title": "Incrementing id that uniquely identifies this entry"
        },
        "unbondingOnHoldRefCount": {
          "type": "string",
          "format": "int64",
          "title": "Strictly positive if this entry's unbonding has been stopped by external modules"
        }
      },
      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
    },
    "cosmos.staking.v1beta1.RedelegationEntryResponse": {
      "type": "object",
      "properties": {
        "redelegationEntry": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.RedelegationEntry"
        },
        "balance": {
          "type": "string"
        }
      },
      "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
    },
    "cosmos.staking.v1beta1.RedelegationResponse": {
      "type": "object",
      "properties": {
        "redelegation": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Redelegation"
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.RedelegationEntryResponse"
          }
        }
      },
      "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
    },
    "cosmos.staking.v1beta1.UnbondingDelegation": {
      "type": "object",
      "properties": {
        "delegatorAddress": {
          "type": "string",
          "description": "delegator_address is the encoded address of the delegator."
        },
        "validatorAddress": {
          "type": "string",
          "description": "validator_address is the encoded address of the validator."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.staking.v1beta1.UnbondingDelegationEntry"
          },
          "description": "entries are the unbonding delegation entries.\n\nunbonding delegation entries"
        }
      },
      "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
    },
    "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
      "type": "object",
      "properties": {
        "creationHeight": {
          "type": "string",
          "format": "int64",
          "description": "creation_height is the height which the unbonding took place."
        },
        "completionTime": {
          "type": "string",
          "format": "date-time",
          "description": "completion_time is the unix time for unbonding completion."
        },
        "initialBalance": {
          "type": "string",
          "description": "initial_balance defines the tokens initially scheduled to receive at completion."
        },
        "balance": {
          "type": "string",
          "description": "balance defines the tokens to receive at completion."
        },
        "unbondingId": {
          "type": "string",
          "format": "uint64",
          "title": "Incrementing id that uniquely identifies this entry"
        },
        "unbondingOnHoldRefCount": {
          "type": "string",
          "format": "int64",
          "title": "Strictly positive if this entry's unbonding has been stopped by external modules"
        }
      },
      "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
    },
    "cosmos.staking.v1beta1.Validator": {
      "type": "object",
      "properties": {
        "operatorAddress": {
          "type": "string",
          "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
        },
        "consensusPubkey": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "consensus_pubkey is the consensus public key of the validator, as a Protobuf Any."
        },
        "jailed": {
          "type": "boolean",
          "description": "jailed defined whether the validator has been jailed from bonded status or not."
        },
        "status": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.BondStatus",
          "description": "status is the validator status (bonded/unbonding/unbonded)."
        },
        "tokens": {
          "type": "string",
          "description": "tokens define the delegated tokens (incl. self-delegation)."
        },
        "delegatorShares": {
          "type": "string",
          "description": "delegator_shares defines total shares issued to a validator's delegators."
        },
        "description": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
          "description": "description defines the description terms for the validator."
        },
        "unbondingHeight": {
          "type": "string",
          "format": "int64",
          "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."
        },
        "unbondingTime": {
          "type": "string",
          "format": "date-time",
          "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."
        },
        "commission": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Commission",
          "description": "commission defines the commission parameters."
        },
        "minSelfDelegation": {
          "type": "string",
          "description": "min_self_delegation is the validator's self declared minimum self delegation."
        },
        "unbondingOnHoldRefCount": {
          "type": "string",
          "format": "int64",
          "title": "strictly positive if this validator's unbonding has been stopped by external modules"
        },
        "unbondingIds": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator"
        }
      },
      "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
    },
    "cosmos.tx.signing.v1beta1.SignMode": {
      "type": "string",
      "enum": [
        "SIGN_MODE_UNSPECIFIED",
        "SIGN_MODE_DIRECT",
        "SIGN_MODE_TEXTUAL",
        "SIGN_MODE_DIRECT_AUX",
        "SIGN_MODE_LEGACY_AMINO_JSON",
        "SIGN_MODE_EIP_191"
      ],
      "default": "SIGN_MODE_UNSPECIFIED",
      "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT.\n\nSince: cosmos-sdk 0.50\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2"
    },
    "cosmos.tx.v1beta1.AuthInfo": {
      "type": "object",
      "properties": {
        "signerInfos": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.tx.v1beta1.SignerInfo"
          },
          "description": "signer_infos defines the signing modes for the required signers. The number\nand order of elements must match the required signers from TxBody's\nmessages. The first element is the primary signer and the one which pays\nthe fee."
        },
        "fee": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Fee",
          "description": "Fee is the fee and gas limit for the transaction. The first signer is the\nprimary signer and the one which pays the fee. The fee can be calculated\nbased on the cost of evaluating the body and doing signature verification\nof the signers. This can be estimated via simulation."
        },
        "tip": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tip",
          "description": "Tip is the optional tip used for transactions fees paid in another denom.\n\nThis field is ignored if the chain didn't enable tips, i.e. didn't add the\n`TipDecorator` in its posthandler."
        }
      },
      "description": "AuthInfo describes the fee and signer modes that are used to sign a\ntransaction."
    },
    "cosmos.tx.v1beta1.BroadcastMode": {
      "type": "string",
      "enum": [
        "BROADCAST_MODE_UNSPECIFIED",
        "BROADCAST_MODE_BLOCK",
        "BROADCAST_MODE_SYNC",
        "BROADCAST_MODE_ASYNC"
      ],
      "default": "BROADCAST_MODE_UNSPECIFIED",
      "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC\nmethod.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits\nfor a CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client\nreturns immediately."
    },
    "cosmos.tx.v1beta1.BroadcastTxRequest": {
      "type": "object",
      "properties": {
        "txBytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        },
        "mode": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.BroadcastMode"
        }
      },
      "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
    },
    "cosmos.tx.v1beta1.BroadcastTxResponse": {
      "type": "object",
      "properties": {
        "txResponse": {
          "$ref": "#/definitions/cosmos.base.abci.v1beta1.TxResponse",
          "description": "tx_response is the queried TxResponses."
        }
      },
      "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
    },
    "cosmos.tx.v1beta1.Fee": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "amount is the amount of coins to be paid as a fee"
        },
        "gasLimit": {
          "type": "string",
          "format": "uint64",
          "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs"
        },
        "payer": {
          "type": "string",
          "description": "if unset, the first signer is responsible for paying the fees. If set, the\nspecified account must pay the fees. the payer must be a tx signer (and\nthus have signed this field in AuthInfo). setting this field does *not*\nchange the ordering of required signers for the transaction."
        },
        "granter": {
          "type": "string",
          "title": "if set, the fee payer (either the first signer or the value of the payer\nfield) requests that a fee grant be used to pay fees instead of the fee\npayer's own balance. If an appropriate fee grant does not exist or the\nchain does not support fee grants, this will fail"
        }
      },
      "description": "Fee includes the amount of coins paid in fees and the maximum\ngas to be used by the transaction. The ratio yields an effective \"gasprice\",\nwhich must be above some miminum to be accepted into the mempool."
    },
    "cosmos.tx.v1beta1.GetBlockWithTxsResponse": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
          },
          "description": "txs are the transactions in the block."
        },
        "blockId": {
          "$ref": "#/definitions/cometbft.types.v2.BlockID"
        },
        "block": {
          "$ref": "#/definitions/cometbft.types.v2.Block"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines a pagination for the response."
        }
      },
      "description": "GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs\nmethod."
    },
    "cosmos.tx.v1beta1.GetTxResponse": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the queried transaction."
        },
        "txResponse": {
          "$ref": "#/definitions/cosmos.base.abci.v1beta1.TxResponse",
          "description": "tx_response is the queried TxResponses."
        }
      },
      "description": "GetTxResponse is the response type for the Service.GetTx method."
    },
    "cosmos.tx.v1beta1.GetTxsEventResponse": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
          },
          "description": "txs is the list of queried transactions."
        },
        "txResponses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.abci.v1beta1.TxResponse"
          },
          "description": "tx_responses is the list of queried TxResponses."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines a pagination for the response.\nDeprecated post v0.46.x: use total instead."
        },
        "total": {
          "type": "string",
          "format": "uint64",
          "title": "total is total number of results available"
        }
      },
      "description": "GetTxsEventResponse is the response type for the Service.TxsByEvents\nRPC method."
    },
    "cosmos.tx.v1beta1.ModeInfo": {
      "type": "object",
      "properties": {
        "single": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo.Single",
          "title": "single represents a single signer"
        },
        "multi": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo.Multi",
          "title": "multi represents a nested multisig signer"
        }
      },
      "description": "ModeInfo describes the signing mode of a single or nested multisig signer."
    },
    "cosmos.tx.v1beta1.ModeInfo.Multi": {
      "type": "object",
      "properties": {
        "bitarray": {
          "$ref": "#/definitions/cosmos.crypto.multisig.v1beta1.CompactBitArray",
          "title": "bitarray specifies which keys within the multisig are signing"
        },
        "modeInfos": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo"
          },
          "title": "mode_infos is the corresponding modes of the signers of the multisig\nwhich could include nested multisig public keys"
        }
      },
      "title": "Multi is the mode info for a multisig public key"
    },
    "cosmos.tx.v1beta1.ModeInfo.Single": {
      "type": "object",
      "properties": {
        "mode": {
          "$ref": "#/definitions/cosmos.tx.signing.v1beta1.SignMode",
          "title": "mode is the signing mode of the single signer"
        }
      },
      "title": "Single is the mode info for a single signer. It is structured as a message\nto allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\nfuture"
    },
    "cosmos.tx.v1beta1.OrderBy": {
      "type": "string",
      "enum": [
        "ORDER_BY_UNSPECIFIED",
        "ORDER_BY_ASC",
        "ORDER_BY_DESC"
      ],
      "default": "ORDER_BY_UNSPECIFIED",
      "description": "- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults\nto ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
      "title": "OrderBy defines the sorting order"
    },
    "cosmos.tx.v1beta1.SignerInfo": {
      "type": "object",
      "properties": {
        "publicKey": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "public_key is the public key of the signer. It is optional for accounts\nthat already exist in state. If unset, the verifier can use the required \\\nsigner address for this position and lookup the public key."
        },
        "modeInfo": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo",
          "title": "mode_info describes the signing mode of the signer and is a nested\nstructure to support nested multisig pubkey's"
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the sequence of the account, which describes the\nnumber of committed transactions signed by a given address. It is used to\nprevent replay attacks."
        }
      },
      "description": "SignerInfo describes the public key and signing mode of a single top-level\nsigner."
    },
    "cosmos.tx.v1beta1.SimulateRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the transaction to simulate.\nDeprecated. Send raw tx bytes instead."
        },
        "txBytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        }
      },
      "description": "SimulateRequest is the request type for the Service.Simulate\nRPC method."
    },
    "cosmos.tx.v1beta1.SimulateResponse": {
      "type": "object",
      "properties": {
        "gasInfo": {
          "$ref": "#/definitions/cosmos.base.abci.v1beta1.GasInfo",
          "description": "gas_info is the information about gas used in the simulation."
        },
        "result": {
          "$ref": "#/definitions/cosmos.base.abci.v1beta1.Result",
          "description": "result is the result of the simulation."
        }
      },
      "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
    },
    "cosmos.tx.v1beta1.Tip": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "amount is the amount of the tip"
        },
        "tipper": {
          "type": "string",
          "title": "tipper is the address of the account paying for the tip"
        }
      },
      "description": "Tip is the tip used for meta-transactions."
    },
    "cosmos.tx.v1beta1.Tx": {
      "type": "object",
      "properties": {
        "body": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.TxBody",
          "title": "body is the processable content of the transaction"
        },
        "authInfo": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.AuthInfo",
          "title": "auth_info is the authorization related content of the transaction,\nspecifically signers, signer modes and fee"
        },
        "signatures": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "signatures is a list of signatures that matches the length and order of\nAuthInfo's signer_infos to allow connecting signature meta information like\npublic key and signing mode by position."
        }
      },
      "description": "Tx is the standard type used for broadcasting transactions."
    },
    "cosmos.tx.v1beta1.TxBody": {
      "type": "object",
      "properties": {
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction."
        },
        "memo": {
          "type": "string",
          "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see\nhttps://github.com/cosmos/cosmos-sdk/issues/9122)."
        },
        "timeoutHeight": {
          "type": "string",
          "format": "uint64",
          "description": "timeout_height is the block height after which this transaction will not\nbe processed by the chain."
        },
        "unordered": {
          "type": "boolean",
          "description": "unordered, when set to true, indicates that the transaction signer(s)\nintend for the transaction to be evaluated and executed in an un-ordered\nfashion. Specifically, the account's nonce will NOT be checked or\nincremented, which allows for fire-and-forget as well as concurrent\ntransaction execution.\n\nNote, when set to true, the existing 'timeout_timestamp' value must\nbe set and will be used to correspond to a timestamp in which the transaction is deemed\nvalid.\n\nWhen true, the sequence value MUST be 0, and any transaction with unordered=true and a non-zero sequence value will\nbe rejected.\nExternal services that make assumptions about sequence values may need to be updated because of this."
        },
        "timeoutTimestamp": {
          "type": "string",
          "format": "date-time",
          "description": "timeout_timestamp is the block time after which this transaction will not\nbe processed by the chain.\n\nNote, if unordered=true this value MUST be set\nand will act as a short-lived TTL in which the transaction is deemed valid\nand kept in memory to prevent duplicates."
        },
        "extensionOptions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected"
        },
        "nonCriticalExtensionOptions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          },
          "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored"
        }
      },
      "description": "TxBody is the body of a transaction that all signers sign over."
    },
    "cosmos.tx.v1beta1.TxDecodeAminoRequest": {
      "type": "object",
      "properties": {
        "aminoBinary": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino\nRPC method."
    },
    "cosmos.tx.v1beta1.TxDecodeAminoResponse": {
      "type": "object",
      "properties": {
        "aminoJson": {
          "type": "string"
        }
      },
      "description": "TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino\nRPC method."
    },
    "cosmos.tx.v1beta1.TxDecodeRequest": {
      "type": "object",
      "properties": {
        "txBytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        }
      },
      "description": "TxDecodeRequest is the request type for the Service.TxDecode\nRPC method."
    },
    "cosmos.tx.v1beta1.TxDecodeResponse": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the decoded transaction."
        }
      },
      "description": "TxDecodeResponse is the response type for the\nService.TxDecode method."
    },
    "cosmos.tx.v1beta1.TxEncodeAminoRequest": {
      "type": "object",
      "properties": {
        "aminoJson": {
          "type": "string"
        }
      },
      "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino\nRPC method."
    },
    "cosmos.tx.v1beta1.TxEncodeAminoResponse": {
      "type": "object",
      "properties": {
        "aminoBinary": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino\nRPC method."
    },
    "cosmos.tx.v1beta1.TxEncodeRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the transaction to encode."
        }
      },
      "description": "TxEncodeRequest is the request type for the Service.TxEncode\nRPC method."
    },
    "cosmos.tx.v1beta1.TxEncodeResponse": {
      "type": "object",
      "properties": {
        "txBytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the encoded transaction bytes."
        }
      },
      "description": "TxEncodeResponse is the response type for the\nService.TxEncode method."
    },
    "cosmos.upgrade.v1beta1.ModuleVersion": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name of the app module"
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "title": "consensus version of the app module"
        }
      },
      "description": "ModuleVersion specifies a module and its consensus version."
    },
    "cosmos.upgrade.v1beta1.Plan": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
        },
        "height": {
          "type": "string",
          "format": "int64",
          "description": "The height at which the upgrade must be performed."
        },
        "info": {
          "type": "string",
          "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
        },
        "upgradedClientState": {
          "$ref": "#/definitions/google.protobuf.Any",
          "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been\nmoved to the IBC module in the sub module 02-client.\nIf this field is not empty, an error will be thrown."
        }
      },
      "description": "Plan specifies information about a planned upgrade and when it should occur."
    },
    "cosmos.upgrade.v1beta1.QueryAppliedPlanResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "description": "height is the block height at which the plan was applied."
        }
      },
      "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod."
    },
    "cosmos.upgrade.v1beta1.QueryAuthorityResponse": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        }
      },
      "title": "QueryAuthorityResponse is the response type for Query/Authority"
    },
    "cosmos.upgrade.v1beta1.QueryCurrentPlanResponse": {
      "type": "object",
      "properties": {
        "plan": {
          "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
          "description": "plan is the current upgrade plan."
        }
      },
      "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod."
    },
    "cosmos.upgrade.v1beta1.QueryModuleVersionsResponse": {
      "type": "object",
      "properties": {
        "moduleVersions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.upgrade.v1beta1.ModuleVersion"
          },
          "description": "module_versions is a list of module names with their consensus versions."
        }
      },
      "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method."
    },
    "cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse": {
      "type": "object",
      "properties": {
        "upgradedConsensusState": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\nRPC method."
    },
    "cosmos.vesting.v1beta1.Period": {
      "type": "object",
      "properties": {
        "length": {
          "type": "string",
          "format": "int64",
          "description": "Period duration in seconds."
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          }
        }
      },
      "description": "Period defines a length of time and amount of coins that will vest."
    },
    "ethermint.evm.v1.AccessControl": {
      "type": "object",
      "properties": {
        "create": {
          "$ref": "#/definitions/ethermint.evm.v1.AccessControlType",
          "title": "create defines the permission policy for creating contracts"
        },
        "call": {
          "$ref": "#/definitions/ethermint.evm.v1.AccessControlType",
          "title": "call defines the permission policy for calling contracts"
        }
      },
      "title": "AccessControl defines the permission policy of the EVM\nfor creating and calling contracts"
    },
    "ethermint.evm.v1.AccessControlType": {
      "type": "object",
      "properties": {
        "accessType": {
          "$ref": "#/definitions/ethermint.evm.v1.AccessType",
          "title": "access_type defines which type of permission is required for the operation"
        },
        "accessControlList": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "access_control_list defines defines different things depending on the\nAccessType:\n- ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from\nperforming the operation\n- ACCESS_TYPE_RESTRICTED: ignored\n- ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform\nthe operation"
        }
      },
      "title": "AccessControlType defines the permission type for policies"
    },
    "ethermint.evm.v1.AccessType": {
      "type": "string",
      "enum": [
        "ACCESS_TYPE_PERMISSIONLESS",
        "ACCESS_TYPE_RESTRICTED",
        "ACCESS_TYPE_PERMISSIONED"
      ],
      "default": "ACCESS_TYPE_PERMISSIONLESS",
      "description": "- ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone\n - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone\n - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses",
      "title": "AccessType defines the types of permissions for the operations"
    },
    "ethermint.evm.v1.ChainConfig": {
      "type": "object",
      "properties": {
        "homesteadBlock": {
          "type": "string",
          "title": "homestead_block switch (nil no fork, 0 = already homestead)"
        },
        "daoForkBlock": {
          "type": "string",
          "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)"
        },
        "daoForkSupport": {
          "type": "boolean",
          "title": "dao_fork_support defines whether the nodes supports or opposes the DAO\nhard-fork"
        },
        "eip150Block": {
          "type": "string",
          "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)"
        },
        "eip150Hash": {
          "type": "string",
          "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas\npricing changed)"
        },
        "eip155Block": {
          "type": "string",
          "title": "eip155_block: EIP155Block HF block"
        },
        "eip158Block": {
          "type": "string",
          "title": "eip158_block: EIP158 HF block"
        },
        "byzantiumBlock": {
          "type": "string",
          "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on\nbyzantium)"
        },
        "constantinopleBlock": {
          "type": "string",
          "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already\nactivated)"
        },
        "petersburgBlock": {
          "type": "string",
          "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)"
        },
        "istanbulBlock": {
          "type": "string",
          "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on\nistanbul)"
        },
        "muirGlacierBlock": {
          "type": "string",
          "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =\nalready activated)"
        },
        "berlinBlock": {
          "type": "string",
          "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)"
        },
        "londonBlock": {
          "type": "string",
          "title": "london_block: London switch block (nil = no fork, 0 = already on london)"
        },
        "arrowGlacierBlock": {
          "type": "string",
          "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =\nalready activated)"
        },
        "grayGlacierBlock": {
          "type": "string",
          "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =\nalready activated)"
        },
        "mergeNetsplitBlock": {
          "type": "string",
          "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network\nsplitter"
        },
        "shanghaiBlock": {
          "type": "string",
          "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)"
        },
        "cancunBlock": {
          "type": "string",
          "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)"
        }
      },
      "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
    },
    "ethermint.evm.v1.EstimateGasResponse": {
      "type": "object",
      "properties": {
        "gas": {
          "type": "string",
          "format": "uint64",
          "title": "gas returns the estimated gas"
        }
      },
      "title": "EstimateGasResponse defines EstimateGas response"
    },
    "ethermint.evm.v1.Log": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "title": "address of the contract that generated the event"
        },
        "topics": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "topics is a list of topics provided by the contract."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data which is supplied by the contract, usually ABI-encoded"
        },
        "blockNumber": {
          "type": "string",
          "format": "uint64",
          "title": "block_number of the block in which the transaction was included"
        },
        "txHash": {
          "type": "string",
          "title": "tx_hash is the transaction hash"
        },
        "txIndex": {
          "type": "string",
          "format": "uint64",
          "title": "tx_index of the transaction in the block"
        },
        "blockHash": {
          "type": "string",
          "title": "block_hash of the block in which the transaction was included"
        },
        "index": {
          "type": "string",
          "format": "uint64",
          "title": "index of the log in the block"
        },
        "removed": {
          "type": "boolean",
          "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
        }
      },
      "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
    },
    "ethermint.evm.v1.MsgEthereumTx": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/google.protobuf.Any",
          "title": "data is inner transaction data of the Ethereum transaction"
        },
        "size": {
          "type": "number",
          "format": "double",
          "title": "size is the encoded storage size of the transaction (DEPRECATED)"
        },
        "hash": {
          "type": "string",
          "title": "hash of the transaction in hex format"
        },
        "from": {
          "type": "string",
          "title": "from is the ethereum signer address in hex format. This address value is\nchecked against the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve"
        }
      },
      "description": "MsgEthereumTx encapsulates an Ethereum transaction as an SDK message."
    },
    "ethermint.evm.v1.MsgEthereumTxResponse": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "title": "hash of the ethereum transaction in hex format. This hash differs from the\nTendermint sha256 hash of the transaction bytes. See\nhttps://github.com/tendermint/tendermint/issues/6539 for reference"
        },
        "logs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ethermint.evm.v1.Log"
          },
          "description": "logs contains the transaction hash and the proto-compatible ethereum\nlogs."
        },
        "ret": {
          "type": "string",
          "format": "byte",
          "title": "ret is the returned data from evm function (result or data supplied with\nrevert opcode)"
        },
        "vmError": {
          "type": "string",
          "title": "vm_error is the error returned by vm execution"
        },
        "gasUsed": {
          "type": "string",
          "format": "uint64",
          "title": "gas_used specifies how much gas was consumed by the transaction"
        }
      },
      "description": "MsgEthereumTxResponse defines the Msg/EthereumTx response type."
    },
    "ethermint.evm.v1.Params": {
      "type": "object",
      "properties": {
        "evmDenom": {
          "type": "string",
          "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
        },
        "extraEips": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "extra_eips defines the additional EIPs for the vm.Config"
        },
        "chainConfig": {
          "$ref": "#/definitions/ethermint.evm.v1.ChainConfig",
          "title": "chain_config defines the EVM chain configuration parameters"
        },
        "allowUnprotectedTxs": {
          "type": "boolean",
          "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
        },
        "evmChannels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "evm_channels is the list of channel identifiers from EVM compatible chains"
        },
        "accessControl": {
          "$ref": "#/definitions/ethermint.evm.v1.AccessControl",
          "title": "access_control defines the permission policy of the EVM"
        },
        "activeStaticPrecompiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "active_static_precompiles defines the slice of hex addresses of the\nprecompiled contracts that are active"
        }
      },
      "title": "Params defines the EVM module parameters"
    },
    "ethermint.evm.v1.QueryAccountResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "string",
          "description": "balance is the balance of the EVM denomination."
        },
        "codeHash": {
          "type": "string",
          "description": "code_hash is the hex-formatted code bytes from the EOA."
        },
        "nonce": {
          "type": "string",
          "format": "uint64",
          "description": "nonce is the account's sequence number."
        }
      },
      "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
    },
    "ethermint.evm.v1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "string",
          "description": "balance is the balance of the EVM denomination."
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "ethermint.evm.v1.QueryBaseFeeResponse": {
      "type": "object",
      "properties": {
        "baseFee": {
          "type": "string",
          "title": "base_fee is the EIP1559 base fee"
        }
      },
      "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
    },
    "ethermint.evm.v1.QueryCodeResponse": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "format": "byte",
          "description": "code represents the code bytes from an ethereum address."
        }
      },
      "description": "QueryCodeResponse is the response type for the Query/Code RPC\nmethod."
    },
    "ethermint.evm.v1.QueryCosmosAccountResponse": {
      "type": "object",
      "properties": {
        "cosmosAddress": {
          "type": "string",
          "description": "cosmos_address is the cosmos address of the account."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the account's sequence number."
        },
        "accountNumber": {
          "type": "string",
          "format": "uint64",
          "title": "account_number is the account number"
        }
      },
      "description": "QueryCosmosAccountResponse is the response type for the Query/CosmosAccount\nRPC method."
    },
    "ethermint.evm.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/ethermint.evm.v1.Params",
          "description": "params define the evm module parameters."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
    },
    "ethermint.evm.v1.QueryStorageResponse": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "description": "value defines the storage state value hash associated with the given key."
        }
      },
      "description": "QueryStorageResponse is the response type for the Query/Storage RPC\nmethod."
    },
    "ethermint.evm.v1.QueryTraceBlockResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data is the response serialized in bytes"
        }
      },
      "title": "QueryTraceBlockResponse defines TraceBlock response"
    },
    "ethermint.evm.v1.QueryTraceTxResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data is the response serialized in bytes"
        }
      },
      "title": "QueryTraceTxResponse defines TraceTx response"
    },
    "ethermint.evm.v1.QueryValidatorAccountResponse": {
      "type": "object",
      "properties": {
        "accountAddress": {
          "type": "string",
          "description": "account_address is the cosmos address of the account in bech32 format."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the account's sequence number."
        },
        "accountNumber": {
          "type": "string",
          "format": "uint64",
          "title": "account_number is the account number"
        }
      },
      "description": "QueryValidatorAccountResponse is the response type for the\nQuery/ValidatorAccount RPC method."
    },
    "ethermint.evm.v1.TraceConfig": {
      "type": "object",
      "properties": {
        "tracer": {
          "type": "string",
          "title": "tracer is a custom javascript tracer"
        },
        "timeout": {
          "type": "string",
          "title": "timeout overrides the default timeout of 5 seconds for JavaScript-based\ntracing calls"
        },
        "reexec": {
          "type": "string",
          "format": "uint64",
          "title": "reexec defines the number of blocks the tracer is willing to go back"
        },
        "disableStack": {
          "type": "boolean",
          "title": "disable_stack switches stack capture"
        },
        "disableStorage": {
          "type": "boolean",
          "title": "disable_storage switches storage capture"
        },
        "debug": {
          "type": "boolean",
          "title": "debug can be used to print output during capture end"
        },
        "limit": {
          "type": "integer",
          "format": "int32",
          "title": "limit defines the maximum length of output, but zero means unlimited"
        },
        "overrides": {
          "$ref": "#/definitions/ethermint.evm.v1.ChainConfig",
          "title": "overrides can be used to execute a trace using future fork rules"
        },
        "enableMemory": {
          "type": "boolean",
          "title": "enable_memory switches memory capture"
        },
        "enableReturnData": {
          "type": "boolean",
          "title": "enable_return_data switches the capture of return data"
        },
        "tracerJsonConfig": {
          "type": "string",
          "title": "tracer_json_config configures the tracer using a JSON string"
        }
      },
      "description": "TraceConfig holds extra parameters to trace functions."
    },
    "ethermint.feemarket.v1.Params": {
      "type": "object",
      "properties": {
        "noBaseFee": {
          "type": "boolean",
          "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)"
        },
        "baseFeeChangeDenominator": {
          "type": "integer",
          "format": "int64",
          "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks."
        },
        "elasticityMultiplier": {
          "type": "integer",
          "format": "int64",
          "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave."
        },
        "enableHeight": {
          "type": "string",
          "format": "int64",
          "description": "enable_height defines at which block height the base fee calculation is\nenabled."
        },
        "baseFee": {
          "type": "string",
          "description": "base_fee for EIP-1559 blocks."
        },
        "minGasPrice": {
          "type": "string",
          "title": "min_gas_price defines the minimum gas price value for cosmos and eth\ntransactions"
        },
        "minGasMultiplier": {
          "type": "string",
          "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit"
        }
      },
      "title": "Params defines the EVM module parameters"
    },
    "ethermint.feemarket.v1.QueryBaseFeeResponse": {
      "type": "object",
      "properties": {
        "baseFee": {
          "type": "string",
          "title": "base_fee is the EIP1559 base fee"
        }
      },
      "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
    },
    "ethermint.feemarket.v1.QueryBlockGasResponse": {
      "type": "object",
      "properties": {
        "gas": {
          "type": "string",
          "format": "int64",
          "title": "gas is the returned block gas"
        }
      },
      "description": "QueryBlockGasResponse returns block gas used for a given height."
    },
    "ethermint.feemarket.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/ethermint.feemarket.v1.Params",
          "description": "params define the evm module parameters."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
    },
    "evmos.epochs.v1.EpochInfo": {
      "type": "object",
      "properties": {
        "identifier": {
          "type": "string",
          "title": "identifier of the epoch"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "start_time of the epoch"
        },
        "duration": {
          "type": "string",
          "title": "duration of the epoch"
        },
        "currentEpoch": {
          "type": "string",
          "format": "int64",
          "title": "current_epoch is the integer identifier of the epoch"
        },
        "currentEpochStartTime": {
          "type": "string",
          "format": "date-time",
          "title": "current_epoch_start_time defines the timestamp of the start of the epoch"
        },
        "epochCountingStarted": {
          "type": "boolean",
          "title": "epoch_counting_started reflects if the counting for the epoch has started"
        },
        "currentEpochStartHeight": {
          "type": "string",
          "format": "int64",
          "title": "current_epoch_start_height of the epoch"
        }
      },
      "description": "EpochInfo defines the message interface containing the relevant informations\nabout an epoch."
    },
    "evmos.epochs.v1.QueryCurrentEpochResponse": {
      "type": "object",
      "properties": {
        "currentEpoch": {
          "type": "string",
          "format": "int64",
          "title": "current_epoch is the number of the current epoch"
        }
      },
      "description": "QueryCurrentEpochResponse is the response type for the Query/EpochInfos RPC\nmethod."
    },
    "evmos.epochs.v1.QueryEpochsInfoResponse": {
      "type": "object",
      "properties": {
        "epochs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/evmos.epochs.v1.EpochInfo"
          },
          "title": "epochs is a slice of all EpochInfos"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines an optional pagination for the request."
        }
      },
      "description": "QueryEpochsInfoResponse is the response type for the Query/EpochInfos RPC\nmethod."
    },
    "evmos.erc20.v1.Owner": {
      "type": "string",
      "enum": [
        "OWNER_UNSPECIFIED",
        "OWNER_MODULE",
        "OWNER_EXTERNAL"
      ],
      "default": "OWNER_UNSPECIFIED",
      "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an externally owned account."
    },
    "evmos.erc20.v1.Params": {
      "type": "object",
      "properties": {
        "enableErc20": {
          "type": "boolean",
          "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <-->\nERC20 tokens."
        },
        "nativePrecompiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "native_precompiles defines the slice of hex addresses of the\nactive precompiles that are used to interact with native staking coins as\nERC20s"
        },
        "dynamicPrecompiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "dynamic_precompiles defines the slice of hex addresses of the\nactive precompiles that are used to interact with Bank coins as ERC20s"
        }
      },
      "title": "Params defines the erc20 module params"
    },
    "evmos.erc20.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/evmos.erc20.v1.Params",
          "title": "params are the erc20 module parameters"
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
    },
    "evmos.erc20.v1.QueryTokenPairResponse": {
      "type": "object",
      "properties": {
        "tokenPair": {
          "$ref": "#/definitions/evmos.erc20.v1.TokenPair",
          "title": "token_pairs returns the info about a registered token pair for the erc20\nmodule"
        }
      },
      "description": "QueryTokenPairResponse is the response type for the Query/TokenPair RPC\nmethod."
    },
    "evmos.erc20.v1.QueryTokenPairsResponse": {
      "type": "object",
      "properties": {
        "tokenPairs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/evmos.erc20.v1.TokenPair"
          },
          "title": "token_pairs is a slice of registered token pairs for the erc20 module"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC\nmethod."
    },
    "evmos.erc20.v1.TokenPair": {
      "type": "object",
      "properties": {
        "erc20Address": {
          "type": "string",
          "title": "erc20_address is the hex address of ERC20 contract token"
        },
        "denom": {
          "type": "string",
          "title": "denom defines the cosmos base denomination to be mapped to"
        },
        "enabled": {
          "type": "boolean",
          "title": "enabled defines the token mapping enable status"
        },
        "contractOwner": {
          "$ref": "#/definitions/evmos.erc20.v1.Owner",
          "title": "contract_owner is an ENUM specifying the type of ERC20 owner (0 invalid, 1\nModuleAccount, 2 external address)"
        }
      },
      "description": "TokenPair defines an instance that records a pairing consisting of a native\nCosmos Coin and an ERC20 token address."
    },
    "google.protobuf.Any": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "google.rpc.Status": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/google.protobuf.Any"
          }
        }
      }
    },
    "haqq.coinomics.v1.Params": {
      "type": "object",
      "properties": {
        "mintDenom": {
          "type": "string",
          "title": "type of coin to mint"
        },
        "enableCoinomics": {
          "type": "boolean",
          "title": "parameter to enable coinmoics"
        },
        "rewardCoefficient": {
          "type": "string",
          "title": "current staking reward coefficient"
        }
      },
      "description": "Params holds parameters for the coinomics module."
    },
    "haqq.coinomics.v1.QueryMaxSupplyResponse": {
      "type": "object",
      "properties": {
        "maxSupply": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
        }
      }
    },
    "haqq.coinomics.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/haqq.coinomics.v1.Params",
          "description": "params defines the parameters of the module."
        }
      }
    },
    "haqq.coinomics.v1.QueryRewardCoefficientResponse": {
      "type": "object",
      "properties": {
        "rewardCoefficient": {
          "type": "string",
          "title": "rate by which the total supply increases within one era"
        }
      }
    },
    "haqq.liquidvesting.v1.Denom": {
      "type": "object",
      "properties": {
        "baseDenom": {
          "type": "string",
          "description": "base_denom main identifier for the denom, used to query it from store."
        },
        "displayDenom": {
          "type": "string",
          "title": "display_denom identifier used for display name for broad audience"
        },
        "originalDenom": {
          "type": "string",
          "title": "original_denom which liquid denom derived from"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "start date"
        },
        "endTime": {
          "type": "string",
          "format": "date-time",
          "title": "end_date"
        },
        "lockupPeriods": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
          },
          "title": "lockup periods"
        }
      },
      "title": "Denom represents liquid token bonded to some specific vesting schedule"
    },
    "haqq.liquidvesting.v1.QueryDenomResponse": {
      "type": "object",
      "properties": {
        "denom": {
          "$ref": "#/definitions/haqq.liquidvesting.v1.Denom",
          "title": "denom is liquidated vesting token"
        }
      },
      "title": "QueryDenomResponse is response for Denom rpc method"
    },
    "haqq.liquidvesting.v1.QueryDenomsResponse": {
      "type": "object",
      "properties": {
        "denoms": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/haqq.liquidvesting.v1.Denom"
          },
          "title": "denoms are liquidated vesting tokens"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "title": "QueryDenomsResponse is response for Denoms rpc method"
    },
    "haqq.ucdao.v1.AllowedCollateral": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "description": "value is the allowed collateral value."
        },
        "type": {
          "$ref": "#/definitions/haqq.ucdao.v1.CollateralValueType",
          "description": "type is the allowed collateral value type."
        }
      }
    },
    "haqq.ucdao.v1.Balance": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the address of the balance holder."
        },
        "coins": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "coins defines the different coins this balance holds."
        }
      },
      "description": "Balance defines an account address and balance pair used in the bank module's\ngenesis state."
    },
    "haqq.ucdao.v1.CollateralValueType": {
      "type": "string",
      "enum": [
        "COLLATERAL_VALUE_TYPE_UNSPECIFIED",
        "COLLATERAL_VALUE_TYPE_STRICT",
        "COLLATERAL_VALUE_TYPE_MASK"
      ],
      "default": "COLLATERAL_VALUE_TYPE_UNSPECIFIED",
      "description": "CollateralValueType defines the type of collateral value.\n\n - COLLATERAL_VALUE_TYPE_UNSPECIFIED: COLLATERAL_VALUE_TYPE_UNSPECIFIED is the unspecified collateral value type.\n - COLLATERAL_VALUE_TYPE_STRICT: COLLATERAL_VALUE_TYPE_STRICT is the strict collateral value type.\n - COLLATERAL_VALUE_TYPE_MASK: COLLATERAL_VALUE_TYPE_MASK is the mask collateral value type."
    },
    "haqq.ucdao.v1.Params": {
      "type": "object",
      "properties": {
        "enableDao": {
          "type": "boolean",
          "description": "enable_dao is the parameter to enable the module functionality."
        },
        "allowedCollaterals": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/haqq.ucdao.v1.AllowedCollateral"
          },
          "description": "allowed_collaterals is the allowed collateral values."
        }
      },
      "description": "Params defines the parameters for the dao module."
    },
    "haqq.ucdao.v1.QueryAllBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "description": "balances is the balances of all the coins."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response."
        }
      },
      "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
    },
    "haqq.ucdao.v1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "description": "balance is the balance of the coin."
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "haqq.ucdao.v1.QueryHoldersResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/haqq.ucdao.v1.Balance"
          },
          "description": "balances is the balances of all the coins."
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "QueryHoldersResponse is the response type for the Query/Holders RPC method."
    },
    "haqq.ucdao.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/haqq.ucdao.v1.Params"
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/ucdao\nparameters."
    },
    "haqq.ucdao.v1.QueryTotalBalanceResponse": {
      "type": "object",
      "properties": {
        "totalBalance": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "supply is the supply of the coins"
        },
        "pagination": {
          "$ref": "#/definitions/cosmos.base.query.v1beta1.PageResponse",
          "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "title": "QueryTotalBalanceResponse is the response type for the Query/TotalBalance RPC\nmethod"
    },
    "haqq.vesting.v1.QueryBalancesResponse": {
      "type": "object",
      "properties": {
        "locked": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "locked defines the current amount of locked tokens"
        },
        "unvested": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "unvested defines the current amount of unvested tokens"
        },
        "vested": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "vested defines the current amount of vested tokens"
        }
      },
      "description": "QueryBalancesResponse is the response type for the Query/Balances RPC\nmethod."
    },
    "haqq.vesting.v1.QueryTotalLockedResponse": {
      "type": "object",
      "properties": {
        "locked": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "locked defines the current amount of locked tokens"
        },
        "unvested": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "unvested defines the current amount of unvested tokens"
        },
        "vested": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "title": "vested defines the current amount of vested tokens"
        }
      },
      "description": "QueryTotalLockedResponse is the response type for the Query/TotalLocked RPC\nmethod."
    }
  }
}
